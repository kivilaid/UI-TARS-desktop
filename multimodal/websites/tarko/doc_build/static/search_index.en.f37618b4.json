[{"title":"Agent Server API","content":"#\n\nComplete API reference for the Tarko Agent Server.\n\n\nComing Soon#\n\nThis section is under development. Check back soon for detailed API\ndocumentation including:\n\n * Server constructor options\n * HTTP endpoints\n * WebSocket events\n * Configuration interfaces\n * Response schemas\n\nFor now, see Server Guide for usage examples.","routePath":"/api/agent-server","lang":"en","toc":[{"text":"Coming Soon","id":"coming-soon","depth":2,"charIndex":55}],"frontmatter":{"title":"Agent Server API","description":"Complete API reference for Tarko Agent Server"},"version":""},{"title":"Agent API","content":"#\n\nComplete API reference for the Tarko Agent class.\n\n\nComing Soon#\n\nThis section is under development. Check back soon for detailed API\ndocumentation including:\n\n * Agent constructor options\n * Method signatures\n * Event types\n * Configuration interfaces\n * Type definitions\n\nFor now, see Quick Start Guide for basic usage examples.","routePath":"/api/agent","lang":"en","toc":[{"text":"Coming Soon","id":"coming-soon","depth":2,"charIndex":54}],"frontmatter":{"title":"Agent API","description":"Complete API reference for Tarko Agent"},"version":""},{"title":"Context Engineering API","content":"#\n\nComplete API reference for Tarko Context Engineering.\n\n\nComing Soon#\n\nThis section is under development. Check back soon for detailed API\ndocumentation including:\n\n * Context Engineering configuration\n * Compression strategies\n * Windowing algorithms\n * Persistence options\n * Custom implementations\n\nFor now, see Context Engineering Guide for usage examples.","routePath":"/api/context-engineering","lang":"en","toc":[{"text":"Coming Soon","id":"coming-soon","depth":2,"charIndex":58}],"frontmatter":{"title":"Context Engineering API","description":"Complete API reference for Tarko Context Engineering"},"version":""},{"title":"Hooks API","content":"#\n\nComplete API reference for Tarko Agent Hooks.\n\n\nComing Soon#\n\nThis section is under development. Check back soon for detailed API\ndocumentation including:\n\n * Hook interfaces\n * Context objects\n * Hook composition\n * Plugin architecture\n * Custom hook development\n\nFor now, see Agent Hooks Guide for usage examples.","routePath":"/api/hooks","lang":"en","toc":[{"text":"Coming Soon","id":"coming-soon","depth":2,"charIndex":50}],"frontmatter":{"title":"Hooks API","description":"Complete API reference for Tarko Agent Hooks"},"version":""},{"title":"Tool Call Engine API","content":"#\n\nComplete API reference for the Tarko Tool Call Engine.\n\n\nComing Soon#\n\nThis section is under development. Check back soon for detailed API\ndocumentation including:\n\n * Tool Call Engine interfaces\n * Tool creation utilities\n * Parser configurations\n * Error handling types\n * Custom engine implementation\n\nFor now, see Tool Call Engine Guide for usage examples.","routePath":"/api/tool-call-engine","lang":"en","toc":[{"text":"Coming Soon","id":"coming-soon","depth":2,"charIndex":59}],"frontmatter":{"title":"Tool Call Engine API","description":"Complete API reference for Tarko Tool Call Engine"},"version":""},{"title":"Custom Hooks","content":"#\n\nLearn how to extend agent behavior with custom hooks.\n\n\nComing Soon#\n\nThis section is under development. Check back soon for detailed examples of:\n\n * Hook composition patterns\n * Plugin development\n * Monitoring and analytics hooks\n * Performance optimization hooks\n * Error handling and recovery hooks\n\nFor now, see Agent Hooks Guide for basic hook usage.","routePath":"/examples/custom-hooks","lang":"en","toc":[{"text":"Coming Soon","id":"coming-soon","depth":2,"charIndex":58}],"frontmatter":{"title":"Custom Hooks","description":"Extend agent behavior with custom hooks"},"version":""},{"title":"Custom Tools","content":"#\n\nLearn how to build advanced custom tools for your Tarko agents.\n\n\nComing Soon#\n\nThis section is under development. Check back soon for detailed examples of:\n\n * Advanced tool patterns\n * Tool composition\n * Streaming tools\n * Tool validation and error handling\n * Tool testing strategies\n\nFor now, see Getting Started Examples for basic tool creation.","routePath":"/examples/custom-tools","lang":"en","toc":[{"text":"Coming Soon","id":"coming-soon","depth":2,"charIndex":68}],"frontmatter":{"title":"Custom Tools","description":"Build advanced custom tools for your Tarko agents"},"version":""},{"title":"Getting Started Examples","content":"#\n\nThis page provides practical examples to help you get started with Tarko\nquickly.\n\n\nBasic Agent#\n\nCreate a simple agent with basic functionality:\n\n\n\n// Create a simple greeting tool\nconst greetingTool = createTool({\n  name: 'greet_user',\n  description: 'Greet a user with their name',\n  parameters: {\n    type: 'object',\n    properties: {\n      name: {\n        type: 'string',\n        description: 'The user\\'s name'\n      }\n    },\n    required: ['name']\n  },\n  handler: async ({ name }) => {\n    return `Hello, ${name}! Nice to meet you!`;\n  }\n});\n\n// Create the agent\nconst agent = new Agent({\n  name: 'GreetingBot',\n  description: 'A friendly greeting assistant',\n  systemPrompt: 'You are a friendly assistant that helps users with greetings.',\n  tools: [greetingTool],\n  modelProvider: {\n    apiKey: process.env.OPENAI_API_KEY,\n    baseURL: 'https://api.openai.com/v1',\n    model: 'gpt-4'\n  }\n});\n\nexport default agent;\n\n\n\nWeather Agent#\n\nBuild an agent that can fetch weather information:\n\n\n\n// Weather tool with real API integration\nconst weatherTool = createTool({\n  name: 'get_weather',\n  description: 'Get current weather information for a location',\n  parameters: {\n    type: 'object',\n    properties: {\n      location: {\n        type: 'string',\n        description: 'City name or coordinates (e.g., \"New York\" or \"40.7128,-74.0060\")'\n      },\n      units: {\n        type: 'string',\n        enum: ['metric', 'imperial'],\n        default: 'metric',\n        description: 'Temperature units'\n      }\n    },\n    required: ['location']\n  },\n  handler: async ({ location, units = 'metric' }) => {\n    const apiKey = process.env.OPENWEATHER_API_KEY;\n    if (!apiKey) {\n      throw new Error('OpenWeather API key not configured');\n    }\n\n    try {\n      const response = await fetch(\n        `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(location)}&appid=${apiKey}&units=${units}`\n      );\n      \n      if (!response.ok) {\n        throw new Error(`Weather API error: ${response.statusText}`);\n      }\n      \n      const data = await response.json();\n      \n      const temperature = Math.round(data.main.temp);\n      const description = data.weather[0].description;\n      const humidity = data.main.humidity;\n      const windSpeed = data.wind.speed;\n      const unitSymbol = units === 'metric' ? 'Â°C' : 'Â°F';\n      const speedUnit = units === 'metric' ? 'm/s' : 'mph';\n      \n      return `Weather in ${data.name}, ${data.sys.country}:\nðŸŒ¡ï¸ Temperature: ${temperature}${unitSymbol}\nðŸŒ¤ï¸ Condition: ${description}\nðŸ’§ Humidity: ${humidity}%\nðŸ’¨ Wind Speed: ${windSpeed} ${speedUnit}`;\n    } catch (error) {\n      return `Sorry, I couldn't fetch weather data for \"${location}\". Please check the location name and try again.`;\n    }\n  }\n});\n\nconst weatherAgent = new Agent({\n  name: 'WeatherBot',\n  description: 'A helpful weather assistant',\n  systemPrompt: `You are a weather assistant that provides current weather information for any location.\nUse the get_weather tool to fetch real-time weather data when users ask about weather conditions.\nAlways be helpful and provide clear, formatted weather information.`,\n  tools: [weatherTool],\n  modelProvider: {\n    apiKey: process.env.OPENAI_API_KEY,\n    baseURL: 'https://api.openai.com/v1',\n    model: 'gpt-4'\n  }\n});\n\nexport default weatherAgent;\n\n\n\nCalculator Agent#\n\nCreate an agent with mathematical capabilities:\n\n\n\n// Safe math evaluation tool\nconst calculatorTool = createTool({\n  name: 'calculate',\n  description: 'Perform mathematical calculations safely',\n  parameters: {\n    type: 'object',\n    properties: {\n      expression: {\n        type: 'string',\n        description: 'Mathematical expression (e.g., \"2 + 3 * 4\", \"sqrt(16)\", \"sin(pi/2)\")'\n      }\n    },\n    required: ['expression']\n  },\n  validate: ({ expression }) => {\n    // Basic validation for safety\n    const allowedPattern = /^[0-9+\\-*/().\\s,sqrt,sin,cos,tan,log,ln,pi,e]+$/i;\n    if (!allowedPattern.test(expression)) {\n      throw new Error('Expression contains invalid characters. Only numbers, basic operators, and common math functions are allowed.');\n    }\n    return true;\n  },\n  handler: async ({ expression }) => {\n    try {\n      // Replace common math functions and constants\n      let safeExpression = expression\n        .replace(/pi/gi, 'Math.PI')\n        .replace(/e(?![0-9])/gi, 'Math.E')\n        .replace(/sqrt\\(/gi, 'Math.sqrt(')\n        .replace(/sin\\(/gi, 'Math.sin(')\n        .replace(/cos\\(/gi, 'Math.cos(')\n        .replace(/tan\\(/gi, 'Math.tan(')\n        .replace(/log\\(/gi, 'Math.log10(')\n        .replace(/ln\\(/gi, 'Math.log(');\n      \n      // Use Function constructor for safer evaluation\n      const result = new Function('return ' + safeExpression)();\n      \n      if (typeof result !== 'number' || !isFinite(result)) {\n        throw new Error('Invalid calculation result');\n      }\n      \n      return `${expression} = ${result}`;\n    } catch (error) {\n      return `Error calculating \"${expression}\": ${error.message}`;\n    }\n  }\n});\n\n// Unit conversion tool\nconst unitConverterTool = createTool({\n  name: 'convert_units',\n  description: 'Convert between different units of measurement',\n  parameters: {\n    type: 'object',\n    properties: {\n      value: {\n        type: 'number',\n        description: 'The numeric value to convert'\n      },\n      fromUnit: {\n        type: 'string',\n        description: 'Source unit (e.g., \"celsius\", \"fahrenheit\", \"meters\", \"feet\", \"kg\", \"lbs\")'\n      },\n      toUnit: {\n        type: 'string',\n        description: 'Target unit'\n      }\n    },\n    required: ['value', 'fromUnit', 'toUnit']\n  },\n  handler: async ({ value, fromUnit, toUnit }) => {\n    const conversions: Record<string, Record<string, (v: number) => number>> = {\n      // Temperature\n      celsius: {\n        fahrenheit: (c) => (c * 9/5) + 32,\n        kelvin: (c) => c + 273.15\n      },\n      fahrenheit: {\n        celsius: (f) => (f - 32) * 5/9,\n        kelvin: (f) => ((f - 32) * 5/9) + 273.15\n      },\n      kelvin: {\n        celsius: (k) => k - 273.15,\n        fahrenheit: (k) => ((k - 273.15) * 9/5) + 32\n      },\n      // Length\n      meters: {\n        feet: (m) => m * 3.28084,\n        inches: (m) => m * 39.3701,\n        kilometers: (m) => m / 1000\n      },\n      feet: {\n        meters: (ft) => ft / 3.28084,\n        inches: (ft) => ft * 12,\n        kilometers: (ft) => ft / 3280.84\n      },\n      // Weight\n      kg: {\n        lbs: (kg) => kg * 2.20462,\n        grams: (kg) => kg * 1000\n      },\n      lbs: {\n        kg: (lbs) => lbs / 2.20462,\n        grams: (lbs) => (lbs / 2.20462) * 1000\n      }\n    };\n    \n    const fromKey = fromUnit.toLowerCase();\n    const toKey = toUnit.toLowerCase();\n    \n    if (!conversions[fromKey] || !conversions[fromKey][toKey]) {\n      return `Conversion from ${fromUnit} to ${toUnit} is not supported. Available conversions: temperature (celsius, fahrenheit, kelvin), length (meters, feet, inches, kilometers), weight (kg, lbs, grams).`;\n    }\n    \n    const result = conversions[fromKey][toKey](value);\n    return `${value} ${fromUnit} = ${result.toFixed(4)} ${toUnit}`;\n  }\n});\n\nconst calculatorAgent = new Agent({\n  name: 'MathBot',\n  description: 'A mathematical assistant for calculations and unit conversions',\n  systemPrompt: `You are a helpful mathematical assistant that can:\n1. Perform calculations using the calculate tool\n2. Convert between different units using the convert_units tool\n\nAlways use the appropriate tool for mathematical operations and unit conversions.\nProvide clear explanations of your calculations when helpful.`,\n  tools: [calculatorTool, unitConverterTool],\n  modelProvider: {\n    apiKey: process.env.OPENAI_API_KEY,\n    baseURL: 'https://api.openai.com/v1',\n    model: 'gpt-4'\n  }\n});\n\nexport default calculatorAgent;\n\n\n\nFile System Agent#\n\nBuild an agent that can interact with the file system:\n\n\n\n\n\n// File reading tool\nconst readFileTool = createTool({\n  name: 'read_file',\n  description: 'Read the contents of a text file',\n  parameters: {\n    type: 'object',\n    properties: {\n      filePath: {\n        type: 'string',\n        description: 'Path to the file to read'\n      }\n    },\n    required: ['filePath']\n  },\n  handler: async ({ filePath }) => {\n    try {\n      // Basic security check - prevent directory traversal\n      const resolvedPath = path.resolve(filePath);\n      const workingDir = process.cwd();\n      \n      if (!resolvedPath.startsWith(workingDir)) {\n        throw new Error('Access denied: File is outside working directory');\n      }\n      \n      const content = await fs.readFile(resolvedPath, 'utf-8');\n      return `File content of ${filePath}:\\n\\n${content}`;\n    } catch (error) {\n      return `Error reading file ${filePath}: ${error.message}`;\n    }\n  }\n});\n\n// Directory listing tool\nconst listDirectoryTool = createTool({\n  name: 'list_directory',\n  description: 'List files and directories in a given path',\n  parameters: {\n    type: 'object',\n    properties: {\n      dirPath: {\n        type: 'string',\n        description: 'Path to the directory to list',\n        default: '.'\n      }\n    }\n  },\n  handler: async ({ dirPath = '.' }) => {\n    try {\n      const resolvedPath = path.resolve(dirPath);\n      const workingDir = process.cwd();\n      \n      if (!resolvedPath.startsWith(workingDir)) {\n        throw new Error('Access denied: Directory is outside working directory');\n      }\n      \n      const items = await fs.readdir(resolvedPath, { withFileTypes: true });\n      \n      const files = items.filter(item => item.isFile()).map(item => item.name);\n      const dirs = items.filter(item => item.isDirectory()).map(item => item.name);\n      \n      let result = `Contents of ${dirPath}:\\n\\n`;\n      \n      if (dirs.length > 0) {\n        result += `ðŸ“ Directories (${dirs.length}):\\n${dirs.map(d => `  ${d}/`).join('\\n')}\\n\\n`;\n      }\n      \n      if (files.length > 0) {\n        result += `ðŸ“„ Files (${files.length}):\\n${files.map(f => `  ${f}`).join('\\n')}`;\n      }\n      \n      if (dirs.length === 0 && files.length === 0) {\n        result += 'Directory is empty.';\n      }\n      \n      return result;\n    } catch (error) {\n      return `Error listing directory ${dirPath}: ${error.message}`;\n    }\n  }\n});\n\n// File writing tool\nconst writeFileTool = createTool({\n  name: 'write_file',\n  description: 'Write content to a file',\n  parameters: {\n    type: 'object',\n    properties: {\n      filePath: {\n        type: 'string',\n        description: 'Path where to write the file'\n      },\n      content: {\n        type: 'string',\n        description: 'Content to write to the file'\n      }\n    },\n    required: ['filePath', 'content']\n  },\n  handler: async ({ filePath, content }) => {\n    try {\n      const resolvedPath = path.resolve(filePath);\n      const workingDir = process.cwd();\n      \n      if (!resolvedPath.startsWith(workingDir)) {\n        throw new Error('Access denied: File is outside working directory');\n      }\n      \n      // Ensure directory exists\n      const dir = path.dirname(resolvedPath);\n      await fs.mkdir(dir, { recursive: true });\n      \n      await fs.writeFile(resolvedPath, content, 'utf-8');\n      return `Successfully wrote ${content.length} characters to ${filePath}`;\n    } catch (error) {\n      return `Error writing file ${filePath}: ${error.message}`;\n    }\n  }\n});\n\nconst fileSystemAgent = new Agent({\n  name: 'FileBot',\n  description: 'A file system assistant for reading, writing, and managing files',\n  systemPrompt: `You are a helpful file system assistant that can:\n1. Read file contents using read_file\n2. List directory contents using list_directory\n3. Write files using write_file\n\nAlways be careful with file operations and provide clear feedback about what you're doing.\nFor security, you can only access files within the current working directory.`,\n  tools: [readFileTool, listDirectoryTool, writeFileTool],\n  modelProvider: {\n    apiKey: process.env.OPENAI_API_KEY,\n    baseURL: 'https://api.openai.com/v1',\n    model: 'gpt-4'\n  }\n});\n\nexport default fileSystemAgent;\n\n\n\nRunning the Examples#\n\n\nEnvironment Setup#\n\nCreate a .env file with your API keys:\n\n# .env file\n# OpenAI API Key (required for all examples)\nOPENAI_API_KEY=your_openai_api_key_here\n\n# OpenWeather API Key (required for weather agent)\nOPENWEATHER_API_KEY=your_openweather_api_key_here\n\n# Optional: Use different model provider\n# MODEL_PROVIDER=anthropic\n# ANTHROPIC_API_KEY=your_anthropic_key_here\n\n\n\nUsing with CLI#\n\nSave any of the examples as a .ts file and run:\n\n# Run the weather agent\nnpx tarko run weather-agent.ts\n\n# Run with custom port\nnpx tarko run calculator-agent.ts --port 3001\n\n# Run in development mode with hot reload\nnpx tarko dev file-system-agent.ts\n\n\n\nProgrammatic Usage#\n\n\n\nasync function main() {\n  // Start a conversation\n  const response = await weatherAgent.query('What\\'s the weather like in Tokyo?');\n  console.log(response);\n  \n  // Continue the conversation\n  const followUp = await weatherAgent.query('How about in London?');\n  console.log(followUp);\n}\n\nmain().catch(console.error);\n\n\n\nTesting Examples#\n\n\n\n\ndescribe('Calculator Agent', () => {\n  it('should perform basic calculations', async () => {\n    const response = await calculatorAgent.query('What is 15 * 7?');\n    expect(response).toContain('105');\n  });\n  \n  it('should convert units', async () => {\n    const response = await calculatorAgent.query('Convert 100 fahrenheit to celsius');\n    expect(response).toContain('37.7778');\n  });\n});\n\n\n\nNext Steps#\n\n * Custom Tools - Learn to build more advanced tools\n * Server Integration - Deploy agents as servers\n * Custom Hooks - Add custom behavior with hooks\n\n\nCommon Issues#\n\n\nAPI Key Not Found#\n\nMake sure your .env file is in the project root and contains the required API\nkeys.\n\n\nFile Access Denied#\n\nThe file system agent only allows access to files within the current working\ndirectory for security reasons.\n\n\nTool Call Failures#\n\nCheck your internet connection and API key validity. Tools will provide error\nmessages to help debug issues.","routePath":"/examples/getting-started","lang":"en","toc":[{"text":"Basic Agent","id":"basic-agent","depth":2,"charIndex":86},{"text":"Weather Agent","id":"weather-agent","depth":2,"charIndex":929},{"text":"Calculator Agent","id":"calculator-agent","depth":2,"charIndex":3324},{"text":"File System Agent","id":"file-system-agent","depth":2,"charIndex":7784},{"text":"Running the Examples","id":"running-the-examples","depth":2,"charIndex":12030},{"text":"Environment Setup","id":"environment-setup","depth":3,"charIndex":12054},{"text":"Using with CLI","id":"using-with-cli","depth":3,"charIndex":12429},{"text":"Programmatic Usage","id":"programmatic-usage","depth":3,"charIndex":12701},{"text":"Testing Examples","id":"testing-examples","depth":3,"charIndex":13045},{"text":"Next Steps","id":"next-steps","depth":2,"charIndex":13463},{"text":"Common Issues","id":"common-issues","depth":2,"charIndex":13629},{"text":"API Key Not Found","id":"api-key-not-found","depth":3,"charIndex":13646},{"text":"File Access Denied","id":"file-access-denied","depth":3,"charIndex":13752},{"text":"Tool Call Failures","id":"tool-call-failures","depth":3,"charIndex":13884}],"frontmatter":{"title":"Getting Started Examples","description":"Practical examples to get started with Tarko"},"version":""},{"title":"Protocol Integration","content":"#\n\nLearn how to integrate with Tarko's Agent Protocol.\n\n\nComing Soon#\n\nThis section is under development. Check back soon for detailed examples of:\n\n * Event stream integration\n * Custom UI development\n * Protocol extensions\n * Real-time communication\n * Third-party integrations\n\nFor now, see Agent Protocol Guide for basic protocol usage.","routePath":"/examples/protocol-integration","lang":"en","toc":[{"text":"Coming Soon","id":"coming-soon","depth":2,"charIndex":56}],"frontmatter":{"title":"Protocol Integration","description":"Integrate with Tarko's Agent Protocol"},"version":""},{"title":"Server Integration","content":"#\n\nLearn how to deploy Tarko agents as production servers.\n\n\nComing Soon#\n\nThis section is under development. Check back soon for detailed examples of:\n\n * Production server deployment\n * Docker containerization\n * Load balancing and scaling\n * Monitoring and logging\n * Authentication and security\n\nFor now, see Server Guide for basic server usage.","routePath":"/examples/server-integration","lang":"en","toc":[{"text":"Coming Soon","id":"coming-soon","depth":2,"charIndex":60}],"frontmatter":{"title":"Server Integration","description":"Deploy Tarko agents as production servers"},"version":""},{"title":"Agent Hooks","content":"#\n\nTarko's Agent Hooks system provides powerful extension points throughout the\nagent lifecycle, allowing you to customize behavior, add monitoring, implement\ncustom logic, and integrate with external systems.\n\n\nOverview#\n\nAgent Hooks are callback functions that execute at specific points during agent\noperation:\n\n * Lifecycle Hooks: Agent startup, shutdown, session management\n * Message Hooks: Before/after message processing\n * Tool Hooks: Tool call execution and result processing\n * Context Hooks: Context engineering operations\n * Error Hooks: Error handling and recovery\n\n\nBasic Hook Usage#\n\n\nDefining Hooks#\n\n\n\nconst agent = new Agent({\n  hooks: {\n    // Lifecycle hooks\n    onStart: async (agent) => {\n      console.log('Agent started:', agent.name);\n    },\n    \n    onStop: async (agent) => {\n      console.log('Agent stopped:', agent.name);\n    },\n    \n    // Message hooks\n    beforeMessage: async (message, context) => {\n      console.log('Processing message:', message.content);\n      return message; // Return modified message or original\n    },\n    \n    afterMessage: async (message, response, context) => {\n      console.log('Message processed. Response length:', response.length);\n    },\n    \n    // Tool hooks\n    beforeToolCall: async (toolCall, context) => {\n      console.log('Calling tool:', toolCall.function.name);\n      return toolCall; // Can modify tool call\n    },\n    \n    afterToolCall: async (toolCall, result, context) => {\n      console.log('Tool completed:', toolCall.function.name, 'Success:', result.success);\n    }\n  }\n});\n\n\n\nHook Context#\n\nAll hooks receive a context object with useful information:\n\ninterface HookContext {\n  agent: Agent;\n  sessionId: string;\n  messages: Message[];\n  agentState: any;\n  user?: UserInfo;\n  metadata: Record<string, any>;\n  \n  // Utility methods\n  emit: (event: AgentEvent) => void;\n  getState: (key: string) => any;\n  setState: (key: string, value: any) => void;\n  callTool: (name: string, args: any) => Promise<any>;\n}\n\n\n\nLifecycle Hooks#\n\n\nAgent Lifecycle#\n\nconst agent = new Agent({\n  hooks: {\n    // Called when agent starts\n    onStart: async (agent) => {\n      console.log(`Agent ${agent.name} starting...`);\n      \n      // Initialize external services\n      await initializeDatabase();\n      await connectToMetrics();\n      \n      // Set initial state\n      agent.setState('startTime', Date.now());\n    },\n    \n    // Called when agent stops\n    onStop: async (agent) => {\n      const startTime = agent.getState('startTime');\n      const uptime = Date.now() - startTime;\n      \n      console.log(`Agent ${agent.name} stopping. Uptime: ${uptime}ms`);\n      \n      // Cleanup resources\n      await closeDatabase();\n      await disconnectFromMetrics();\n    },\n    \n    // Called on agent errors\n    onError: async (error, context) => {\n      console.error('Agent error:', error.message);\n      \n      // Send error to monitoring service\n      await sendErrorToMonitoring(error, context);\n      \n      // Attempt recovery\n      if (error.recoverable) {\n        await attemptRecovery(error, context);\n      }\n    }\n  }\n});\n\n\n\nSession Lifecycle#\n\nconst agent = new Agent({\n  hooks: {\n    // Called when new session starts\n    onSessionStart: async (sessionId, context) => {\n      console.log('New session started:', sessionId);\n      \n      // Initialize session-specific data\n      context.setState('sessionStartTime', Date.now());\n      context.setState('messageCount', 0);\n      \n      // Load user preferences\n      const user = await loadUserPreferences(context.user?.id);\n      context.setState('userPreferences', user);\n    },\n    \n    // Called when session ends\n    onSessionEnd: async (sessionId, context) => {\n      const startTime = context.getState('sessionStartTime');\n      const messageCount = context.getState('messageCount');\n      const duration = Date.now() - startTime;\n      \n      console.log(`Session ${sessionId} ended. Duration: ${duration}ms, Messages: ${messageCount}`);\n      \n      // Save session analytics\n      await saveSessionAnalytics({\n        sessionId,\n        duration,\n        messageCount,\n        userId: context.user?.id\n      });\n    }\n  }\n});\n\n\n\nMessage Processing Hooks#\n\n\nMessage Transformation#\n\nconst agent = new Agent({\n  hooks: {\n    // Preprocess user messages\n    beforeMessage: async (message, context) => {\n      // Add timestamp\n      message.timestamp = Date.now();\n      \n      // Content filtering\n      if (containsInappropriateContent(message.content)) {\n        throw new Error('Message contains inappropriate content');\n      }\n      \n      // Language detection\n      const language = detectLanguage(message.content);\n      message.metadata = { ...message.metadata, language };\n      \n      // Increment message counter\n      const count = context.getState('messageCount') || 0;\n      context.setState('messageCount', count + 1);\n      \n      return message;\n    },\n    \n    // Process assistant responses\n    afterMessage: async (userMessage, assistantResponse, context) => {\n      // Log conversation\n      await logConversation({\n        sessionId: context.sessionId,\n        userMessage: userMessage.content,\n        assistantResponse,\n        timestamp: Date.now()\n      });\n      \n      // Update user engagement metrics\n      await updateEngagementMetrics(context.user?.id, {\n        messageLength: userMessage.content.length,\n        responseLength: assistantResponse.length,\n        responseTime: Date.now() - userMessage.timestamp\n      });\n    },\n    \n    // Handle streaming responses\n    onMessageDelta: async (delta, accumulated, context) => {\n      // Real-time content filtering\n      if (containsInappropriateContent(accumulated)) {\n        context.emit({\n          type: 'content_filter_triggered',\n          data: { reason: 'inappropriate_content' }\n        });\n        \n        // Stop streaming\n        return { stop: true };\n      }\n      \n      // Real-time translation for international users\n      if (context.user?.language !== 'en') {\n        const translatedDelta = await translateText(delta, context.user.language);\n        return { delta: translatedDelta };\n      }\n      \n      return { delta };\n    }\n  }\n});\n\n\n\nTool Execution Hooks#\n\n\nTool Call Monitoring#\n\nconst agent = new Agent({\n  hooks: {\n    // Before tool execution\n    beforeToolCall: async (toolCall, context) => {\n      const startTime = Date.now();\n      \n      // Log tool usage\n      console.log(`Executing tool: ${toolCall.function.name}`);\n      console.log('Arguments:', toolCall.function.arguments);\n      \n      // Check permissions\n      if (!hasToolPermission(context.user, toolCall.function.name)) {\n        throw new Error(`User does not have permission to use ${toolCall.function.name}`);\n      }\n      \n      // Rate limiting\n      const toolUsage = context.getState(`tool_usage_${toolCall.function.name}`) || [];\n      const recentUsage = toolUsage.filter(time => Date.now() - time < 60000); // Last minute\n      \n      if (recentUsage.length >= 10) {\n        throw new Error(`Rate limit exceeded for ${toolCall.function.name}`);\n      }\n      \n      // Update usage tracking\n      recentUsage.push(startTime);\n      context.setState(`tool_usage_${toolCall.function.name}`, recentUsage);\n      context.setState(`tool_start_${toolCall.id}`, startTime);\n      \n      // Emit monitoring event\n      context.emit({\n        type: 'tool_execution_start',\n        data: {\n          toolName: toolCall.function.name,\n          arguments: toolCall.function.arguments,\n          startTime\n        }\n      });\n      \n      return toolCall;\n    },\n    \n    // After tool execution\n    afterToolCall: async (toolCall, result, context) => {\n      const startTime = context.getState(`tool_start_${toolCall.id}`);\n      const duration = Date.now() - startTime;\n      \n      // Log execution results\n      console.log(`Tool ${toolCall.function.name} completed in ${duration}ms`);\n      console.log('Success:', result.success);\n      \n      // Record metrics\n      await recordToolMetrics({\n        toolName: toolCall.function.name,\n        duration,\n        success: result.success,\n        userId: context.user?.id,\n        sessionId: context.sessionId\n      });\n      \n      // Handle errors\n      if (!result.success) {\n        await handleToolError({\n          toolName: toolCall.function.name,\n          error: result.error,\n          arguments: toolCall.function.arguments,\n          context\n        });\n      }\n      \n      // Emit completion event\n      context.emit({\n        type: 'tool_execution_complete',\n        data: {\n          toolName: toolCall.function.name,\n          duration,\n          success: result.success,\n          resultLength: result.content?.length || 0\n        }\n      });\n    },\n    \n    // Handle tool errors\n    onToolError: async (error, toolCall, context) => {\n      console.error(`Tool ${toolCall.function.name} failed:`, error.message);\n      \n      // Attempt automatic retry for transient errors\n      if (isTransientError(error) && !toolCall.retryAttempt) {\n        console.log('Retrying tool call...');\n        \n        // Mark as retry attempt\n        toolCall.retryAttempt = true;\n        \n        // Retry after delay\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        return { retry: true };\n      }\n      \n      // Log persistent failures\n      await logToolFailure({\n        toolName: toolCall.function.name,\n        error: error.message,\n        arguments: toolCall.function.arguments,\n        sessionId: context.sessionId\n      });\n      \n      return { retry: false };\n    }\n  }\n});\n\n\n\nContext Engineering Hooks#\n\n\nContext Management#\n\nconst agent = new Agent({\n  hooks: {\n    // Before context compression\n    beforeContextCompression: async (context, messages) => {\n      console.log(`Compressing context: ${messages.length} messages`);\n      \n      // Save full context before compression\n      await saveContextSnapshot({\n        sessionId: context.sessionId,\n        messages,\n        timestamp: Date.now()\n      });\n      \n      // Custom importance scoring\n      return messages.map(message => ({\n        ...message,\n        importance: calculateImportanceScore(message, context)\n      }));\n    },\n    \n    // After context compression\n    afterContextCompression: async (originalMessages, compressedMessages, context) => {\n      const compressionRatio = compressedMessages.length / originalMessages.length;\n      \n      console.log(`Context compressed: ${originalMessages.length} â†’ ${compressedMessages.length} (${(compressionRatio * 100).toFixed(1)}%)`);\n      \n      // Log compression metrics\n      await logCompressionMetrics({\n        sessionId: context.sessionId,\n        originalLength: originalMessages.length,\n        compressedLength: compressedMessages.length,\n        compressionRatio,\n        timestamp: Date.now()\n      });\n      \n      // Alert if compression ratio is too aggressive\n      if (compressionRatio < 0.3) {\n        console.warn('High compression ratio detected. Consider adjusting compression settings.');\n      }\n    },\n    \n    // Context limit reached\n    onContextLimitReached: async (context, messages) => {\n      console.warn('Context limit reached. Initiating emergency compression.');\n      \n      // Emergency context preservation\n      const criticalMessages = messages.filter(msg => \n        msg.role === 'system' || \n        msg.metadata?.critical === true\n      );\n      \n      await saveEmergencyContext({\n        sessionId: context.sessionId,\n        criticalMessages,\n        allMessages: messages,\n        timestamp: Date.now()\n      });\n      \n      // Emit alert\n      context.emit({\n        type: 'context_limit_alert',\n        data: {\n          messageCount: messages.length,\n          criticalMessageCount: criticalMessages.length\n        }\n      });\n    }\n  }\n});\n\n\n\nCustom Hook Implementation#\n\n\nPlugin System#\n\n// Define a plugin interface\ninterface AgentPlugin {\n  name: string;\n  version: string;\n  hooks: Partial<AgentHooks>;\n  install?: (agent: Agent) => Promise<void>;\n  uninstall?: (agent: Agent) => Promise<void>;\n}\n\n// Analytics plugin\nconst analyticsPlugin: AgentPlugin = {\n  name: 'analytics',\n  version: '1.0.0',\n  hooks: {\n    onSessionStart: async (sessionId, context) => {\n      await analytics.track('session_started', {\n        sessionId,\n        userId: context.user?.id,\n        timestamp: Date.now()\n      });\n    },\n    \n    afterMessage: async (userMessage, response, context) => {\n      await analytics.track('message_processed', {\n        sessionId: context.sessionId,\n        messageLength: userMessage.content.length,\n        responseLength: response.length,\n        timestamp: Date.now()\n      });\n    },\n    \n    afterToolCall: async (toolCall, result, context) => {\n      await analytics.track('tool_used', {\n        toolName: toolCall.function.name,\n        success: result.success,\n        sessionId: context.sessionId,\n        timestamp: Date.now()\n      });\n    }\n  },\n  \n  install: async (agent) => {\n    console.log('Analytics plugin installed');\n    await analytics.initialize(agent.config.analytics);\n  },\n  \n  uninstall: async (agent) => {\n    console.log('Analytics plugin uninstalled');\n    await analytics.cleanup();\n  }\n};\n\n// Use plugin\nconst agent = new Agent({\n  plugins: [analyticsPlugin]\n});\n\n\n\nConditional Hooks#\n\nconst agent = new Agent({\n  hooks: {\n    // Development-only hooks\n    ...(process.env.NODE_ENV === 'development' && {\n      beforeMessage: async (message, context) => {\n        console.log('ðŸ” Debug - Processing message:', message.content);\n        return message;\n      },\n      \n      afterToolCall: async (toolCall, result, context) => {\n        console.log('ðŸ”§ Debug - Tool result:', {\n          tool: toolCall.function.name,\n          success: result.success,\n          resultLength: result.content?.length\n        });\n      }\n    }),\n    \n    // Production-only hooks\n    ...(process.env.NODE_ENV === 'production' && {\n      onError: async (error, context) => {\n        await sendErrorToSentry(error, {\n          sessionId: context.sessionId,\n          userId: context.user?.id,\n          agentName: context.agent.name\n        });\n      }\n    }),\n    \n    // User-specific hooks\n    beforeMessage: async (message, context) => {\n      // Premium user features\n      if (context.user?.tier === 'premium') {\n        message.metadata = {\n          ...message.metadata,\n          priority: 'high',\n          features: ['advanced_tools', 'priority_processing']\n        };\n      }\n      \n      return message;\n    }\n  }\n});\n\n\n\nAdvanced Hook Patterns#\n\n\nHook Composition#\n\n// Compose multiple hooks\nfunction composeHooks<T extends (...args: any[]) => any>(\n  ...hooks: T[]\n): T {\n  return ((...args: Parameters<T>) => {\n    return hooks.reduce(async (prev, hook) => {\n      await prev;\n      return hook(...args);\n    }, Promise.resolve());\n  }) as T;\n}\n\nconst loggingHook = async (message: Message, context: HookContext) => {\n  console.log('Logging:', message.content);\n};\n\nconst analyticsHook = async (message: Message, context: HookContext) => {\n  await analytics.track('message', { length: message.content.length });\n};\n\nconst validationHook = async (message: Message, context: HookContext) => {\n  if (!message.content.trim()) {\n    throw new Error('Empty message not allowed');\n  }\n};\n\nconst agent = new Agent({\n  hooks: {\n    beforeMessage: composeHooks(validationHook, loggingHook, analyticsHook)\n  }\n});\n\n\n\nAsync Hook Patterns#\n\nconst agent = new Agent({\n  hooks: {\n    // Parallel execution\n    afterMessage: async (userMessage, response, context) => {\n      await Promise.all([\n        logToDatabase(userMessage, response, context),\n        sendToAnalytics(userMessage, response, context),\n        updateUserProfile(context.user, response),\n        generateSummary(context.sessionId, response)\n      ]);\n    },\n    \n    // Sequential with error handling\n    beforeToolCall: async (toolCall, context) => {\n      try {\n        // Step 1: Validate permissions\n        await validatePermissions(toolCall, context.user);\n        \n        // Step 2: Check rate limits\n        await checkRateLimit(toolCall.function.name, context.user);\n        \n        // Step 3: Log usage\n        await logToolUsage(toolCall, context);\n        \n        return toolCall;\n      } catch (error) {\n        // Handle validation errors\n        context.emit({\n          type: 'tool_validation_failed',\n          data: { error: error.message, toolName: toolCall.function.name }\n        });\n        throw error;\n      }\n    }\n  }\n});\n\n\n\nTesting Hooks#\n\n\nUnit Testing#\n\n\n\ndescribe('Agent Hooks', () => {\n  let agent: Agent;\n  let mockContext: HookContext;\n  \n  beforeEach(() => {\n    agent = createMockAgent();\n    mockContext = createMockContext({\n      sessionId: 'test-session',\n      user: { id: 'test-user' }\n    });\n  });\n  \n  it('should log messages before processing', async () => {\n    const logSpy = jest.spyOn(console, 'log');\n    \n    const hooks = {\n      beforeMessage: async (message: Message, context: HookContext) => {\n        console.log('Processing:', message.content);\n        return message;\n      }\n    };\n    \n    agent.setHooks(hooks);\n    \n    const message = { role: 'user', content: 'Hello' };\n    await agent.hooks.beforeMessage?.(message, mockContext);\n    \n    expect(logSpy).toHaveBeenCalledWith('Processing:', 'Hello');\n  });\n  \n  it('should handle hook errors gracefully', async () => {\n    const hooks = {\n      beforeMessage: async (message: Message, context: HookContext) => {\n        throw new Error('Hook error');\n      }\n    };\n    \n    agent.setHooks(hooks);\n    \n    const message = { role: 'user', content: 'Hello' };\n    \n    await expect(agent.hooks.beforeMessage?.(message, mockContext))\n      .rejects.toThrow('Hook error');\n  });\n});\n\n\n\nIntegration Testing#\n\ndescribe('Hook Integration', () => {\n  it('should execute hooks in correct order', async () => {\n    const executionOrder: string[] = [];\n    \n    const agent = new Agent({\n      hooks: {\n        beforeMessage: async (message, context) => {\n          executionOrder.push('beforeMessage');\n          return message;\n        },\n        \n        beforeToolCall: async (toolCall, context) => {\n          executionOrder.push('beforeToolCall');\n          return toolCall;\n        },\n        \n        afterToolCall: async (toolCall, result, context) => {\n          executionOrder.push('afterToolCall');\n        },\n        \n        afterMessage: async (userMessage, response, context) => {\n          executionOrder.push('afterMessage');\n        }\n      },\n      tools: [testTool]\n    });\n    \n    await agent.query('Use the test tool');\n    \n    expect(executionOrder).toEqual([\n      'beforeMessage',\n      'beforeToolCall', \n      'afterToolCall',\n      'afterMessage'\n    ]);\n  });\n});\n\n\n\nBest Practices#\n\n\n1. Hook Design#\n\n * Keep hooks focused and lightweight\n * Handle errors gracefully\n * Use async/await for asynchronous operations\n * Return modified data when appropriate\n\n\n2. Performance#\n\n * Avoid blocking operations in critical hooks\n * Use Promise.all() for parallel operations\n * Implement timeouts for external calls\n * Cache expensive computations\n\n\n3. Error Handling#\n\n * Always handle hook errors\n * Provide fallback behavior\n * Log errors for debugging\n * Don't let hook errors break agent operation\n\n\n4. Testing#\n\n * Unit test hooks in isolation\n * Test hook composition and ordering\n * Mock external dependencies\n * Test error scenarios\n\n\nNext Steps#\n\n * Examples - See real-world hook implementations\n * Agent Protocol - Understand event handling in hooks\n * Server - Use hooks in server environments","routePath":"/guide/agent-hooks","lang":"en","toc":[{"text":"Overview","id":"overview","depth":2,"charIndex":211},{"text":"Basic Hook Usage","id":"basic-hook-usage","depth":2,"charIndex":580},{"text":"Defining Hooks","id":"defining-hooks","depth":3,"charIndex":600},{"text":"Hook Context","id":"hook-context","depth":3,"charIndex":1564},{"text":"Lifecycle Hooks","id":"lifecycle-hooks","depth":2,"charIndex":1997},{"text":"Agent Lifecycle","id":"agent-lifecycle","depth":3,"charIndex":2016},{"text":"Session Lifecycle","id":"session-lifecycle","depth":3,"charIndex":3103},{"text":"Message Processing Hooks","id":"message-processing-hooks","depth":2,"charIndex":4168},{"text":"Message Transformation","id":"message-transformation","depth":3,"charIndex":4196},{"text":"Tool Execution Hooks","id":"tool-execution-hooks","depth":2,"charIndex":6185},{"text":"Tool Call Monitoring","id":"tool-call-monitoring","depth":3,"charIndex":6209},{"text":"Context Engineering Hooks","id":"context-engineering-hooks","depth":2,"charIndex":9593},{"text":"Context Management","id":"context-management","depth":3,"charIndex":9622},{"text":"Custom Hook Implementation","id":"custom-hook-implementation","depth":2,"charIndex":11833},{"text":"Plugin System","id":"plugin-system","depth":3,"charIndex":11863},{"text":"Conditional Hooks","id":"conditional-hooks","depth":3,"charIndex":13309},{"text":"Advanced Hook Patterns","id":"advanced-hook-patterns","depth":2,"charIndex":14556},{"text":"Hook Composition","id":"hook-composition","depth":3,"charIndex":14582},{"text":"Async Hook Patterns","id":"async-hook-patterns","depth":3,"charIndex":15443},{"text":"Testing Hooks","id":"testing-hooks","depth":2,"charIndex":16545},{"text":"Unit Testing","id":"unit-testing","depth":3,"charIndex":16562},{"text":"Integration Testing","id":"integration-testing","depth":3,"charIndex":17791},{"text":"Best Practices","id":"best-practices","depth":2,"charIndex":18797},{"text":"1. Hook Design","id":"1-hook-design","depth":3,"charIndex":18815},{"text":"2. Performance","id":"2-performance","depth":3,"charIndex":18988},{"text":"3. Error Handling","id":"3-error-handling","depth":3,"charIndex":19172},{"text":"4. Testing","id":"4-testing","depth":3,"charIndex":19327},{"text":"Next Steps","id":"next-steps","depth":2,"charIndex":19466}],"frontmatter":{"title":"Agent Hooks","description":"Extend and customize agent behavior with powerful hook system"},"version":""},{"title":"Agent Protocol","content":"#\n\nTarko's Agent Protocol defines standardized formats for agent communication,\nenabling seamless integration between components and making Context Engineering\nmore manageable.\n\n\nOverview#\n\nThe Agent Protocol consists of two main components:\n\n 1. Event Stream: Internal communication between agent components\n 2. Server Protocol: HTTP/SSE/WebSocket APIs for external integration\n\n\nEvent Stream Protocol#\n\nThe Event Stream is the core communication mechanism within Tarko agents.\n\n\nEvent Structure#\n\nAll events follow a consistent structure:\n\ninterface AgentEvent {\n  id: string;           // Unique event identifier\n  type: string;         // Event type\n  timestamp: number;    // Unix timestamp\n  sessionId: string;    // Session identifier\n  data: any;           // Event-specific data\n  metadata?: {         // Optional metadata\n    source?: string;   // Event source component\n    version?: string;  // Protocol version\n    traceId?: string;  // Distributed tracing ID\n  };\n}\n\n\n\nCore Event Types#\n\nUser Events#\n\n// User message\n{\n  type: 'user_message',\n  data: {\n    content: string | MessageContent[]; // Text or multimodal content\n    role: 'user';\n  }\n}\n\n// User query (alias for user_message)\n{\n  type: 'user_query',\n  data: {\n    query: string | MessageContent[];\n  }\n}\n\n\nAssistant Events#\n\n// Assistant message start\n{\n  type: 'assistant_message_start',\n  data: {\n    role: 'assistant';\n  }\n}\n\n// Assistant message delta (streaming)\n{\n  type: 'assistant_message_delta',\n  data: {\n    delta: string;\n    accumulated?: string; // Full content so far\n  }\n}\n\n// Assistant message complete\n{\n  type: 'assistant_message',\n  data: {\n    content: string;\n    role: 'assistant';\n    finishReason: 'stop' | 'length' | 'tool_calls';\n  }\n}\n\n\nTool Events#\n\n// Tool call initiated\n{\n  type: 'tool_call',\n  data: {\n    id: string;\n    name: string;\n    arguments: Record<string, any>;\n    type: 'function';\n  }\n}\n\n// Tool execution start\n{\n  type: 'tool_execution_start',\n  data: {\n    toolCallId: string;\n    name: string;\n  }\n}\n\n// Tool execution delta (streaming tools)\n{\n  type: 'tool_execution_delta',\n  data: {\n    toolCallId: string;\n    delta: string;\n    accumulated?: string;\n  }\n}\n\n// Tool execution result\n{\n  type: 'tool_result',\n  data: {\n    toolCallId: string;\n    name: string;\n    content: string;\n    success: boolean;\n    error?: string;\n  }\n}\n\n\nSystem Events#\n\n// Session started\n{\n  type: 'session_start',\n  data: {\n    sessionId: string;\n    agentName: string;\n    timestamp: number;\n  }\n}\n\n// Session ended\n{\n  type: 'session_end',\n  data: {\n    sessionId: string;\n    duration: number;\n    messageCount: number;\n  }\n}\n\n// Error occurred\n{\n  type: 'error',\n  data: {\n    error: string;\n    code?: string;\n    details?: any;\n    recoverable: boolean;\n  }\n}\n\n// Context compression\n{\n  type: 'context_compressed',\n  data: {\n    originalLength: number;\n    compressedLength: number;\n    compressionRatio: number;\n    strategy: string;\n  }\n}\n\n\n\nEvent Stream Usage#\n\nListening to Events#\n\n\n\nconst agent = new Agent({\n  // ... configuration\n});\n\n// Listen to specific event types\nagent.on('assistant_message', (event) => {\n  console.log('Assistant response:', event.data.content);\n});\n\nagent.on('tool_call', (event) => {\n  console.log('Tool called:', event.data.name, event.data.arguments);\n});\n\nagent.on('error', (event) => {\n  console.error('Agent error:', event.data.error);\n});\n\n// Listen to all events\nagent.on('*', (event) => {\n  console.log('Event:', event.type, event.data);\n});\n\n\nEmitting Custom Events#\n\n// Emit custom events from tools or hooks\nagent.emit({\n  type: 'custom_metric',\n  data: {\n    metric: 'response_time',\n    value: 1250,\n    unit: 'ms'\n  }\n});\n\n\nEvent Filtering#\n\n// Filter events by type\nconst toolEvents = agent.getEventStream()\n  .filter(event => event.type.startsWith('tool_'));\n\n// Filter events by session\nconst sessionEvents = agent.getEventStream()\n  .filter(event => event.sessionId === 'specific-session');\n\n// Filter events by time range\nconst recentEvents = agent.getEventStream()\n  .filter(event => event.timestamp > Date.now() - 3600000); // Last hour\n\n\n\nServer Protocol#\n\nThe Server Protocol defines HTTP/SSE/WebSocket APIs for external integration.\n\n\nHTTP REST API#\n\nSession Management#\n\n# Create session\nPOST /api/v1/sessions/create\nContent-Type: application/json\n\n{\n  \"name\": \"My Session\",\n  \"tags\": [\"tag1\", \"tag2\"]\n}\n\n# Response\n{\n  \"sessionId\": \"sess_123\",\n  \"createdAt\": 1622548800000\n}\n\n\n# Execute query\nPOST /api/v1/sessions/query\nContent-Type: application/json\n\n{\n  \"sessionId\": \"sess_123\",\n  \"query\": \"Hello, how can you help?\"\n}\n\n# Response\n{\n  \"response\": \"Hello! I'm here to help...\",\n  \"events\": [\n    {\n      \"type\": \"user_message\",\n      \"data\": { \"content\": \"Hello, how can you help?\" }\n    },\n    {\n      \"type\": \"assistant_message\",\n      \"data\": { \"content\": \"Hello! I'm here to help...\" }\n    }\n  ]\n}\n\n\nEvent History#\n\n# Get session events\nGET /api/v1/sessions/events?sessionId=sess_123&limit=50&offset=0\n\n# Response\n{\n  \"events\": [\n    {\n      \"id\": \"evt_1\",\n      \"type\": \"user_message\",\n      \"timestamp\": 1622548800000,\n      \"sessionId\": \"sess_123\",\n      \"data\": { \"content\": \"Hello\" }\n    }\n  ],\n  \"total\": 125,\n  \"hasMore\": true\n}\n\n\n\nServer-Sent Events (SSE)#\n\nFor real-time streaming:\n\n# Streaming query\nPOST /api/v1/sessions/query/stream\nContent-Type: application/json\nAccept: text/event-stream\n\n{\n  \"sessionId\": \"sess_123\",\n  \"query\": \"Tell me a story\"\n}\n\n\nSSE Response:\n\nevent: user_message\ndata: {\"id\":\"evt_1\",\"type\":\"user_message\",\"data\":{\"content\":\"Tell me a story\"}}\n\nevent: assistant_message_start\ndata: {\"id\":\"evt_2\",\"type\":\"assistant_message_start\",\"data\":{}}\n\nevent: assistant_message_delta\ndata: {\"id\":\"evt_3\",\"type\":\"assistant_message_delta\",\"data\":{\"delta\":\"Once upon\"}}\n\nevent: assistant_message_delta\ndata: {\"id\":\"evt_4\",\"type\":\"assistant_message_delta\",\"data\":{\"delta\":\" a time\"}}\n\nevent: assistant_message\ndata: {\"id\":\"evt_5\",\"type\":\"assistant_message\",\"data\":{\"content\":\"Once upon a time...\"}}\n\n\n\nWebSocket Protocol#\n\nFor bidirectional real-time communication:\n\nconst socket = new WebSocket('ws://localhost:8888/ws');\n\n// Connect to session\nsocket.send(JSON.stringify({\n  type: 'join_session',\n  sessionId: 'sess_123'\n}));\n\n// Send query\nsocket.send(JSON.stringify({\n  type: 'send_query',\n  sessionId: 'sess_123',\n  query: 'Hello!'\n}));\n\n// Receive events\nsocket.onmessage = (event) => {\n  const agentEvent = JSON.parse(event.data);\n  console.log('Received:', agentEvent.type, agentEvent.data);\n};\n\n// Abort query\nsocket.send(JSON.stringify({\n  type: 'abort_query',\n  sessionId: 'sess_123'\n}));\n\n\n\nProtocol Extensions#\n\n\nCustom Event Types#\n\nDefine custom events for your application:\n\n// Define custom event types\ninterface CustomEvents {\n  'user_feedback': {\n    rating: number;\n    comment?: string;\n  };\n  'tool_performance': {\n    toolName: string;\n    executionTime: number;\n    success: boolean;\n  };\n}\n\n// Use with type safety\nagent.on('user_feedback', (event) => {\n  console.log('User rating:', event.data.rating);\n});\n\nagent.emit({\n  type: 'tool_performance',\n  data: {\n    toolName: 'web_search',\n    executionTime: 1250,\n    success: true\n  }\n});\n\n\n\nProtocol Versioning#\n\n// Specify protocol version\nconst agent = new Agent({\n  protocol: {\n    version: '1.0',\n    extensions: ['custom-events', 'performance-metrics']\n  }\n});\n\n// Version-aware event handling\nagent.on('*', (event) => {\n  const version = event.metadata?.version || '1.0';\n  \n  if (version === '1.0') {\n    // Handle v1.0 events\n  } else if (version === '2.0') {\n    // Handle v2.0 events\n  }\n});\n\n\n\nIntegration Examples#\n\n\nReact Integration#\n\n\n\nfunction AgentChat({ sessionId }: { sessionId: string }) {\n  const [events, setEvents] = useState<AgentEvent[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  \n  useEffect(() => {\n    const eventSource = new EventSource(\n      `/api/v1/sessions/events/stream?sessionId=${sessionId}`\n    );\n    \n    eventSource.onmessage = (event) => {\n      const agentEvent = JSON.parse(event.data);\n      setEvents(prev => [...prev, agentEvent]);\n      \n      if (agentEvent.type === 'assistant_message') {\n        setIsLoading(false);\n      }\n    };\n    \n    return () => eventSource.close();\n  }, [sessionId]);\n  \n  const sendMessage = async (message: string) => {\n    setIsLoading(true);\n    \n    await fetch('/api/v1/sessions/query', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ sessionId, query: message })\n    });\n  };\n  \n  return (\n    <div>\n      {events.map(event => (\n        <EventDisplay key={event.id} event={event} />\n      ))}\n      {isLoading && <LoadingIndicator />}\n      <MessageInput onSend={sendMessage} />\n    </div>\n  );\n}\n\n\n\nCLI Integration#\n\n\n\n\nconst agent = new Agent({ /* config */ });\n\n// Display events in CLI\nagent.on('user_message', (event) => {\n  console.log(chalk.blue('User:'), event.data.content);\n});\n\nagent.on('assistant_message_delta', (event) => {\n  process.stdout.write(chalk.green(event.data.delta));\n});\n\nagent.on('assistant_message', (event) => {\n  console.log(); // New line after complete message\n});\n\nagent.on('tool_call', (event) => {\n  console.log(chalk.yellow(`ðŸ”§ Using ${event.data.name}...`));\n});\n\nagent.on('tool_result', (event) => {\n  if (event.data.success) {\n    console.log(chalk.green('âœ… Tool completed'));\n  } else {\n    console.log(chalk.red('âŒ Tool failed:'), event.data.error);\n  }\n});\n\nagent.on('error', (event) => {\n  console.error(chalk.red('Error:'), event.data.error);\n});\n\n\n\nMonitoring Integration#\n\n\n\n\nconst metrics = createPrometheusMetrics();\nconst agent = new Agent({ /* config */ });\n\n// Track metrics from events\nagent.on('assistant_message', (event) => {\n  metrics.responseCount.inc();\n  metrics.responseLength.observe(event.data.content.length);\n});\n\nagent.on('tool_call', (event) => {\n  metrics.toolCallCount.inc({ tool: event.data.name });\n});\n\nagent.on('tool_result', (event) => {\n  const duration = Date.now() - event.timestamp;\n  metrics.toolExecutionDuration.observe(\n    { tool: event.data.name, success: event.data.success },\n    duration\n  );\n});\n\nagent.on('error', (event) => {\n  metrics.errorCount.inc({ type: event.data.code || 'unknown' });\n});\n\n\n\nBest Practices#\n\n\n1. Event Design#\n\n * Use consistent event naming conventions\n * Include all necessary data in event payload\n * Add metadata for debugging and tracing\n * Version your event schemas\n\n\n2. Error Handling#\n\n * Always include error context in error events\n * Use structured error codes\n * Provide actionable error messages\n * Implement proper error recovery\n\n\n3. Performance#\n\n * Batch events when possible\n * Use appropriate event filtering\n * Implement event compression for large payloads\n * Monitor event processing latency\n\n\n4. Security#\n\n * Sanitize event data before transmission\n * Implement proper authentication for event streams\n * Use encryption for sensitive event data\n * Audit event access patterns\n\n\nDebugging and Monitoring#\n\n\nEvent Inspection#\n\n// Enable debug logging\nconst agent = new Agent({\n  debug: {\n    events: true,\n    level: 'verbose'\n  }\n});\n\n// Export event stream for analysis\nconst events = agent.getEventHistory();\nfs.writeFileSync('events.json', JSON.stringify(events, null, 2));\n\n// Real-time event monitoring\nagent.on('*', (event) => {\n  if (process.env.NODE_ENV === 'development') {\n    console.log(`[${event.type}]`, event.data);\n  }\n});\n\n\n\nProtocol Validation#\n\n\n\n// Validate events against schema\nagent.on('*', (event) => {\n  const validation = validateEvent(event, EventSchema);\n  if (!validation.valid) {\n    console.warn('Invalid event:', validation.errors);\n  }\n});\n\n\n\nNext Steps#\n\n * Agent Hooks - Extend protocol behavior\n * Server - Implement server protocol\n * Examples - See protocol integration examples","routePath":"/guide/agent-protocol","lang":"en","toc":[{"text":"Overview","id":"overview","depth":2,"charIndex":178},{"text":"Event Stream Protocol","id":"event-stream-protocol","depth":2,"charIndex":380},{"text":"Event Structure","id":"event-structure","depth":3,"charIndex":480},{"text":"Core Event Types","id":"core-event-types","depth":3,"charIndex":982},{"text":"User Events","id":"user-events","depth":4,"charIndex":1001},{"text":"Assistant Events","id":"assistant-events","depth":4,"charIndex":1281},{"text":"Tool Events","id":"tool-events","depth":4,"charIndex":1740},{"text":"System Events","id":"system-events","depth":4,"charIndex":2361},{"text":"Event Stream Usage","id":"event-stream-usage","depth":3,"charIndex":2960},{"text":"Listening to Events","id":"listening-to-events","depth":4,"charIndex":2981},{"text":"Emitting Custom Events","id":"emitting-custom-events","depth":4,"charIndex":3502},{"text":"Event Filtering","id":"event-filtering","depth":4,"charIndex":3688},{"text":"Server Protocol","id":"server-protocol","depth":2,"charIndex":4111},{"text":"HTTP REST API","id":"http-rest-api","depth":3,"charIndex":4209},{"text":"Session Management","id":"session-management","depth":4,"charIndex":4225},{"text":"Event History","id":"event-history","depth":4,"charIndex":4882},{"text":"Server-Sent Events (SSE)","id":"server-sent-events-sse","depth":3,"charIndex":5221},{"text":"WebSocket Protocol","id":"websocket-protocol","depth":3,"charIndex":6004},{"text":"Protocol Extensions","id":"protocol-extensions","depth":2,"charIndex":6605},{"text":"Custom Event Types","id":"custom-event-types","depth":3,"charIndex":6628},{"text":"Protocol Versioning","id":"protocol-versioning","depth":3,"charIndex":7169},{"text":"Integration Examples","id":"integration-examples","depth":2,"charIndex":7583},{"text":"React Integration","id":"react-integration","depth":3,"charIndex":7607},{"text":"CLI Integration","id":"cli-integration","depth":3,"charIndex":8740},{"text":"Monitoring Integration","id":"monitoring-integration","depth":3,"charIndex":9534},{"text":"Best Practices","id":"best-practices","depth":2,"charIndex":10228},{"text":"1. Event Design","id":"1-event-design","depth":3,"charIndex":10246},{"text":"2. Error Handling","id":"2-error-handling","depth":3,"charIndex":10428},{"text":"3. Performance","id":"3-performance","depth":3,"charIndex":10600},{"text":"4. Security","id":"4-security","depth":3,"charIndex":10770},{"text":"Debugging and Monitoring","id":"debugging-and-monitoring","depth":2,"charIndex":10956},{"text":"Event Inspection","id":"event-inspection","depth":3,"charIndex":10984},{"text":"Protocol Validation","id":"protocol-validation","depth":3,"charIndex":11419},{"text":"Next Steps","id":"next-steps","depth":2,"charIndex":11653}],"frontmatter":{"title":"Agent Protocol","description":"Understand Tarko's standardized communication protocols"},"version":""},{"title":"Architecture","content":"#\n\nTarko is designed with a clean three-layer architecture that separates concerns\nand enables flexible agent development.\n\n\nOverview#\n\ngraph TB\n    subgraph \"Engineering Layer\"\n        CLI[\"Agent CLI\"]\n        Server[\"Agent Server\"]\n        UI[\"Agent UI\"]\n    end\n    \n    subgraph \"Application Layer\"\n        AgentTARS[\"Agent TARS\"]\n        OmniAgent[\"Omni Agent\"]\n        GithubAgent[\"Github Agent\"]\n        CustomAgent[\"Custom Agent\"]\n    end\n    \n    subgraph \"Kernel Layer\"\n        ContextEng[\"Context Engineering\"]\n        ToolCall[\"Tool Call Engine\"]\n        EventStream[\"Event Stream\"]\n        AgentProtocol[\"Agent Protocol\"]\n        ModelProvider[\"Model Provider\"]\n        AgentHooks[\"Agent Hooks\"]\n    end\n    \n    CLI --> AgentTARS\n    Server --> OmniAgent\n    UI --> GithubAgent\n    \n    AgentTARS --> ContextEng\n    OmniAgent --> ToolCall\n    GithubAgent --> EventStream\n    CustomAgent --> AgentProtocol\n\n\n\n1. Engineering Layer#\n\nThe engineering layer provides production-ready solutions for deploying\nTarko-based agents.\n\n\nAgent CLI (@tarko/agent-cli)#\n\nPurpose: One-click agent development and deployment\n\nUse Cases:\n\n * Development: tarko run [agent] for local development\n * Production: One-click deployment to production environments\n\nExample:\n\n# Development\ntarko run my-agent.ts\n\n# Production deployment\ntarko deploy my-agent.ts --platform tars\n\n\n\nAgent Server (@tarko/agent-server)#\n\nPurpose: Node.js API for custom server integrations\n\nUse Cases:\n\n * Custom user authentication\n * Custom storage solutions\n * Integration with existing systems\n\nExample:\n\n\n\nconst server = new AgentServer({\n  agent: myAgent,\n  auth: customAuthProvider,\n  storage: customStorageProvider\n});\n\nserver.listen(3000);\n\n\n\nAgent UI (@tarko/agent-ui)#\n\nPurpose: Official web UI for Tarko Agent Protocol\n\nCustomization Levels:\n\n * L1: Static configuration (most scenarios)\n * L2: UI SDK-based development\n * L3: Build from scratch\n\n\n2. Application Layer#\n\nThe application layer contains Tarko-based agent implementations for specific\nuse cases.\n\n\nAgent TARS#\n\nPurpose: Open-source general-purpose multimodal agent Capabilities: Browser\nautomation, file system, command execution, search, MCP\n\n\nOmni Agent#\n\nPurpose: UI-TARS-2 specialized multimodal agent Capabilities: Same as Agent TARS\nbut optimized for Seed Agent integration\n\n\nGithub Agent#\n\nPurpose: Git workflow and coding agent Capabilities: Github workflow, code\nsearch, code generation, command execution\n\n\nCustom Agents#\n\nDevelopers can build custom agents using the Tarko kernel while maintaining\ncompatibility with the engineering layer.\n\n\n3. Kernel Layer#\n\nThe kernel layer solves core agent runtime challenges.\n\n\nContext Engineering#\n\nProblem: Building agents capable of long-running operations Solution: Advanced\ncontext management with automatic optimization\n\nFeatures:\n\n * Automatic context compression\n * Intelligent context windowing\n * State persistence across sessions\n * Memory optimization\n\n\nTool Call Engine#\n\nProblem: Different LLM providers have varying Tool Call support Solution:\nUnified interface following OpenAI Function Call protocol\n\nSupported Engines:\n\n * Native Function Call (OpenAI, Anthropic)\n * Custom parsers (Seed-1.5 VL)\n * Prompt Engineering (Kor-based)\n\n\nEvent Stream#\n\nProblem: Standard communication between agent components Solution: Unified event\nstream protocol\n\nBenefits:\n\n * Real-time agent state updates\n * Standardized debugging and monitoring\n * Easy UI integration\n\n\nAgent Protocol#\n\nProblem: Inconsistent agent interfaces Solution: Standard protocol definitions\n\nComponents:\n\n * Event Stream: Internal component communication\n * Server Protocol: HTTP/SSE/WebSocket APIs\n\n\nModel Provider#\n\nDesign: OpenAI Compatible protocol Supported Providers: Volcengine, OpenAI,\nAnthropic, Gemini\n\nBenefits:\n\n * Consistent interface across providers\n * Easy model switching for testing\n * Reduced architectural complexity\n\n\nAgent Hooks#\n\nPurpose: Extensible customization points Use Cases: Custom logging, monitoring,\nbehavior modification\n\n\nDesign Principles#\n\n\n1. Separation of Concerns#\n\nEach layer has clear responsibilities and minimal dependencies on other layers.\n\n\n2. Protocol-First Design#\n\nStandardized protocols enable interoperability and tooling ecosystem.\n\n\n3. OpenAI Compatibility#\n\nLeveraging existing standards reduces learning curve and increases\ncompatibility.\n\n\n4. Extensibility#\n\nHooks and protocols allow customization without core modifications.\n\n\nIntegration Points#\n\n\nAgent Development#\n\n\n\n// Application Layer\nconst myAgent = new Agent({\n  // Kernel Layer integration\n  contextEngineering: { /* config */ },\n  toolCallEngine: { /* config */ },\n  hooks: { /* custom hooks */ }\n});\n\n// Engineering Layer consumption\nexport default myAgent;\n\n\n\nProduction Deployment#\n\n# Engineering Layer handles deployment\ntarko run my-agent.ts --production\n\n\n\nNext Steps#\n\n * Context Engineering - Deep dive into context management\n * Tool Call Engine - Learn about tool integration\n * Agent Protocol - Understand communication standards","routePath":"/guide/architecture","lang":"en","toc":[{"text":"Overview","id":"overview","depth":2,"charIndex":124},{"text":"1. Engineering Layer","id":"1-engineering-layer","depth":2,"charIndex":921},{"text":"Agent CLI (`@tarko/agent-cli`)","id":"agent-cli-tarkoagent-cli","depth":3,"charIndex":-1},{"text":"Agent Server (`@tarko/agent-server`)","id":"agent-server-tarkoagent-server","depth":3,"charIndex":-1},{"text":"Agent UI (`@tarko/agent-ui`)","id":"agent-ui-tarkoagent-ui","depth":3,"charIndex":-1},{"text":"2. Application Layer","id":"2-application-layer","depth":2,"charIndex":1928},{"text":"Agent TARS","id":"agent-tars","depth":3,"charIndex":2042},{"text":"Omni Agent","id":"omni-agent","depth":3,"charIndex":2189},{"text":"Github Agent","id":"github-agent","depth":3,"charIndex":2326},{"text":"Custom Agents","id":"custom-agents","depth":3,"charIndex":2461},{"text":"3. Kernel Layer","id":"3-kernel-layer","depth":2,"charIndex":2597},{"text":"Context Engineering","id":"context-engineering","depth":3,"charIndex":2672},{"text":"Tool Call Engine","id":"tool-call-engine","depth":3,"charIndex":2960},{"text":"Event Stream","id":"event-stream","depth":3,"charIndex":3244},{"text":"Agent Protocol","id":"agent-protocol","depth":3,"charIndex":3467},{"text":"Model Provider","id":"model-provider","depth":3,"charIndex":3673},{"text":"Agent Hooks","id":"agent-hooks","depth":3,"charIndex":3911},{"text":"Design Principles","id":"design-principles","depth":2,"charIndex":4029},{"text":"1. Separation of Concerns","id":"1-separation-of-concerns","depth":3,"charIndex":4050},{"text":"2. Protocol-First Design","id":"2-protocol-first-design","depth":3,"charIndex":4160},{"text":"3. OpenAI Compatibility","id":"3-openai-compatibility","depth":3,"charIndex":4259},{"text":"4. Extensibility","id":"4-extensibility","depth":3,"charIndex":4369},{"text":"Integration Points","id":"integration-points","depth":2,"charIndex":4458},{"text":"Agent Development","id":"agent-development","depth":3,"charIndex":4480},{"text":"Production Deployment","id":"production-deployment","depth":3,"charIndex":4754},{"text":"Next Steps","id":"next-steps","depth":2,"charIndex":4855}],"frontmatter":{"title":"Architecture","description":"Understanding Tarko's three-layer architecture"},"version":""},{"title":"Context Engineering","content":"#\n\nContext Engineering is Tarko's core capability for building agents capable of\nlong-running operations. It automatically manages context windows, optimizes\nmemory usage, and maintains agent state across extended sessions.\n\n\nWhat is Context Engineering?#\n\nTraditional agents struggle with long-running tasks due to context window\nlimitations. Context Engineering solves this by:\n\n * Automatic Context Compression: Intelligently summarizes and compresses\n   conversation history\n * Context Windowing: Maintains relevant context while discarding outdated\n   information\n * State Persistence: Preserves important agent state across sessions\n * Memory Optimization: Efficiently manages memory usage for extended operations\n\n\nKey Features#\n\n\n1. Intelligent Context Compression#\n\nWhen context approaches the model's limit, Tarko automatically compresses older\nmessages while preserving critical information.\n\n\n\nconst agent = new Agent({\n  contextEngineering: {\n    enabled: true,\n    compressionStrategy: 'intelligent', // 'intelligent' | 'sliding' | 'custom'\n    maxContextLength: 8000,\n    compressionRatio: 0.3 // Compress to 30% of original size\n  }\n});\n\n\n\n2. Context Windowing Strategies#\n\nSliding Window#\n\nMaintains a fixed-size window of recent messages:\n\ncontextEngineering: {\n  strategy: 'sliding',\n  windowSize: 50 // Keep last 50 messages\n}\n\n\nIntelligent Window#\n\nDynamically adjusts window based on content importance:\n\ncontextEngineering: {\n  strategy: 'intelligent',\n  importanceThreshold: 0.7, // Keep messages above this importance score\n  maxRetention: 100 // Maximum messages to retain\n}\n\n\nCustom Strategy#\n\nImplement your own windowing logic:\n\ncontextEngineering: {\n  strategy: 'custom',\n  windowFunction: (messages, currentLength, maxLength) => {\n    // Custom logic to determine which messages to keep\n    return filteredMessages;\n  }\n}\n\n\n\n3. State Persistence#\n\nMaintain important agent state across sessions:\n\nconst agent = new Agent({\n  contextEngineering: {\n    persistence: {\n      enabled: true,\n      storage: 'file', // 'file' | 'memory' | 'redis' | 'custom'\n      sessionId: 'user-123',\n      retentionPolicy: {\n        maxAge: '7d', // Keep state for 7 days\n        maxSize: '10MB' // Maximum state size\n      }\n    }\n  }\n});\n\n\n\n4. Memory Optimization#\n\nOptimize memory usage for long-running agents:\n\ncontextEngineering: {\n  memoryOptimization: {\n    enabled: true,\n    gcInterval: 300000, // Garbage collect every 5 minutes\n    maxMemoryUsage: '512MB',\n    compressionLevel: 'balanced' // 'fast' | 'balanced' | 'maximum'\n  }\n}\n\n\n\nConfiguration Options#\n\n\nBasic Configuration#\n\ninterface ContextEngineeringConfig {\n  enabled: boolean;\n  maxContextLength: number;\n  compressionStrategy: 'intelligent' | 'sliding' | 'custom';\n  compressionRatio: number;\n}\n\n\n\nAdvanced Configuration#\n\ninterface AdvancedContextConfig {\n  // Windowing\n  windowStrategy: WindowStrategy;\n  importanceScoring: ImportanceScoringConfig;\n  \n  // Persistence\n  persistence: PersistenceConfig;\n  \n  // Memory Management\n  memoryOptimization: MemoryOptimizationConfig;\n  \n  // Custom Hooks\n  hooks: ContextHooks;\n}\n\n\n\nBest Practices#\n\n\n1. Choose the Right Strategy#\n\nUse Sliding Window when:\n\n * Simple use cases with uniform message importance\n * Predictable conversation patterns\n * Performance is critical\n\nUse Intelligent Window when:\n\n * Complex, long-running tasks\n * Variable message importance\n * Need to preserve critical context\n\n\n2. Configure Compression Appropriately#\n\n// For code generation tasks\ncontextEngineering: {\n  compressionStrategy: 'intelligent',\n  compressionRatio: 0.5, // Preserve more detail\n  preservePatterns: ['```', 'TODO:', 'FIXME:']\n}\n\n// For general conversation\ncontextEngineering: {\n  compressionStrategy: 'sliding',\n  compressionRatio: 0.3, // More aggressive compression\n  windowSize: 30\n}\n\n\n\n3. Monitor Context Usage#\n\nagent.on('contextCompressed', (event) => {\n  console.log(`Compressed ${event.originalLength} to ${event.compressedLength}`);\n});\n\nagent.on('contextLimitApproached', (event) => {\n  console.log(`Context at ${event.percentage}% of limit`);\n});\n\n\n\nCustom Context Engineering#\n\n\nCustom Compression Function#\n\nconst customCompressor = (messages: Message[], targetLength: number) => {\n  // Implement custom compression logic\n  const important = messages.filter(msg => \n    msg.role === 'system' || \n    msg.content.includes('IMPORTANT')\n  );\n  \n  const recent = messages.slice(-10); // Last 10 messages\n  \n  return [...important, ...recent].slice(0, targetLength);\n};\n\nconst agent = new Agent({\n  contextEngineering: {\n    strategy: 'custom',\n    compressor: customCompressor\n  }\n});\n\n\n\nCustom Importance Scoring#\n\nconst importanceScorer = (message: Message) => {\n  let score = 0.5; // Base score\n  \n  // System messages are always important\n  if (message.role === 'system') score = 1.0;\n  \n  // Tool calls and results are important\n  if (message.tool_calls || message.tool_call_id) score = 0.9;\n  \n  // Error messages are important\n  if (message.content.toLowerCase().includes('error')) score = 0.8;\n  \n  return score;\n};\n\nconst agent = new Agent({\n  contextEngineering: {\n    importanceScoring: {\n      enabled: true,\n      scorer: importanceScorer,\n      threshold: 0.6\n    }\n  }\n});\n\n\n\nIntegration with Agent Hooks#\n\nContext Engineering integrates with Agent Hooks for custom behavior:\n\nconst agent = new Agent({\n  hooks: {\n    beforeContextCompression: async (context) => {\n      // Log context state before compression\n      console.log('Compressing context:', context.length);\n    },\n    \n    afterContextCompression: async (originalContext, compressedContext) => {\n      // Analyze compression results\n      const ratio = compressedContext.length / originalContext.length;\n      console.log(`Compression ratio: ${ratio}`);\n    },\n    \n    onContextLimitReached: async (context) => {\n      // Handle context limit scenarios\n      await saveContextToStorage(context);\n    }\n  }\n});\n\n\n\nPerformance Considerations#\n\n\nMemory Usage#\n\n * Monitor memory usage with memoryOptimization.maxMemoryUsage\n * Use compression for memory-constrained environments\n * Consider external storage for large contexts\n\n\nProcessing Speed#\n\n * Sliding window is fastest\n * Intelligent compression adds processing overhead\n * Custom strategies should be optimized for your use case\n\n\nStorage Costs#\n\n * File storage is cheapest for persistence\n * Redis provides better performance for shared contexts\n * Consider compression for storage cost optimization\n\n\nDebugging Context Issues#\n\n\nEnable Debug Logging#\n\nconst agent = new Agent({\n  contextEngineering: {\n    debug: true,\n    logLevel: 'verbose'\n  }\n});\n\n\n\nContext Inspection#\n\n// Get current context state\nconst contextState = agent.getContextState();\nconsole.log('Current context length:', contextState.length);\nconsole.log('Compression ratio:', contextState.compressionRatio);\n\n// Export context for analysis\nconst contextDump = agent.exportContext();\nfs.writeFileSync('context-dump.json', JSON.stringify(contextDump, null, 2));\n\n\n\nReal-World Examples#\n\n\nLong-Running Code Assistant#\n\nconst codeAssistant = new Agent({\n  contextEngineering: {\n    strategy: 'intelligent',\n    maxContextLength: 12000,\n    compressionRatio: 0.4,\n    preservePatterns: [\n      /```[\\s\\S]*?```/g, // Code blocks\n      /TODO:|FIXME:|NOTE:/g, // Important comments\n      /class\\s+\\w+/g, // Class definitions\n      /function\\s+\\w+/g // Function definitions\n    ],\n    persistence: {\n      enabled: true,\n      sessionId: 'code-session-123'\n    }\n  }\n});\n\n\n\nCustomer Support Agent#\n\nconst supportAgent = new Agent({\n  contextEngineering: {\n    strategy: 'sliding',\n    windowSize: 50,\n    persistence: {\n      enabled: true,\n      storage: 'redis',\n      sessionId: (context) => context.userId,\n      retentionPolicy: {\n        maxAge: '30d' // Keep support history for 30 days\n      }\n    }\n  }\n});\n\n\n\nNext Steps#\n\n * Tool Call Engine - Learn about tool integration\n * Agent Protocol - Understand communication standards\n * Agent Hooks - Extend agent behavior","routePath":"/guide/context-engineering","lang":"en","toc":[{"text":"What is Context Engineering?","id":"what-is-context-engineering","depth":2,"charIndex":225},{"text":"Key Features","id":"key-features","depth":2,"charIndex":721},{"text":"1. Intelligent Context Compression","id":"1-intelligent-context-compression","depth":3,"charIndex":737},{"text":"2. Context Windowing Strategies","id":"2-context-windowing-strategies","depth":3,"charIndex":1155},{"text":"Sliding Window","id":"sliding-window","depth":4,"charIndex":1189},{"text":"Intelligent Window","id":"intelligent-window","depth":4,"charIndex":1348},{"text":"Custom Strategy","id":"custom-strategy","depth":4,"charIndex":1602},{"text":"3. State Persistence","id":"3-state-persistence","depth":3,"charIndex":1855},{"text":"4. Memory Optimization","id":"4-memory-optimization","depth":3,"charIndex":2254},{"text":"Configuration Options","id":"configuration-options","depth":2,"charIndex":2557},{"text":"Basic Configuration","id":"basic-configuration","depth":3,"charIndex":2582},{"text":"Advanced Configuration","id":"advanced-configuration","depth":3,"charIndex":2783},{"text":"Best Practices","id":"best-practices","depth":2,"charIndex":3114},{"text":"1. Choose the Right Strategy","id":"1-choose-the-right-strategy","depth":3,"charIndex":3132},{"text":"2. Configure Compression Appropriately","id":"2-configure-compression-appropriately","depth":3,"charIndex":3437},{"text":"3. Monitor Context Usage","id":"3-monitor-context-usage","depth":3,"charIndex":3828},{"text":"Custom Context Engineering","id":"custom-context-engineering","depth":2,"charIndex":4099},{"text":"Custom Compression Function","id":"custom-compression-function","depth":3,"charIndex":4129},{"text":"Custom Importance Scoring","id":"custom-importance-scoring","depth":3,"charIndex":4635},{"text":"Integration with Agent Hooks","id":"integration-with-agent-hooks","depth":2,"charIndex":5238},{"text":"Performance Considerations","id":"performance-considerations","depth":2,"charIndex":5939},{"text":"Memory Usage","id":"memory-usage","depth":3,"charIndex":5969},{"text":"Processing Speed","id":"processing-speed","depth":3,"charIndex":6152},{"text":"Storage Costs","id":"storage-costs","depth":3,"charIndex":6313},{"text":"Debugging Context Issues","id":"debugging-context-issues","depth":2,"charIndex":6486},{"text":"Enable Debug Logging","id":"enable-debug-logging","depth":3,"charIndex":6514},{"text":"Context Inspection","id":"context-inspection","depth":3,"charIndex":6639},{"text":"Real-World Examples","id":"real-world-examples","depth":2,"charIndex":7017},{"text":"Long-Running Code Assistant","id":"long-running-code-assistant","depth":3,"charIndex":7040},{"text":"Customer Support Agent","id":"customer-support-agent","depth":3,"charIndex":7519},{"text":"Next Steps","id":"next-steps","depth":2,"charIndex":7864}],"frontmatter":{"title":"Context Engineering","description":"Master long-running agent operations with advanced context management"},"version":""},{"title":"Introduction","content":"#\n\nTarko (Tool-augmented Agent Runtime Kernel, Open-source), pronounced /ËˆtÉ‘ËrkoÊŠ/,\nis a tool-call and event-stream driven Agent runtime framework with powerful\nContext Engineering capabilities.\n\n\nWhat is Tarko?#\n\nTarko provides:\n\n * Context Engineering: Build agents capable of long-running operations\n * Tool Call Engine: Support for multiple LLM providers with custom parsers\n * Event Stream Processing: Native streaming and Agent Protocol support\n * Agent Hooks: Powerful extension capabilities\n * Agent Protocol: Standard format definitions for agent lifecycle\n\n\nKey Features#\n\n\nðŸ”§ Tool Call Engine#\n\nSupport for multiple Tool Call engines including native Function Call, custom\nparsers, and models that don't support native Function Tool.\n\n\nðŸŒŠ Event Stream#\n\nBuilt-in event stream processing with native streaming support and standardized\nAgent Protocol.\n\n\nðŸ§  Context Engineering#\n\nAdvanced context management for long-running agent operations with automatic\ncontext optimization.\n\n\nðŸ”Œ Agent Hooks#\n\nExtensible hook system for customizing agent behavior at every stage of\nexecution.\n\n\nArchitecture Overview#\n\nTarko is built with a three-layer architecture:\n\n 1. Engineering Layer: CLI, Server, and UI components\n 2. Application Layer: Tarko-based Agent implementations\n 3. Kernel Layer: Core runtime with Context Engineering and Agent Protocol\n\n\nWho Uses Tarko?#\n\nTarko powers several production systems:\n\n * UI-TARS-2: Advanced UI automation\n * UI-TARS-desktop: Desktop automation\n * Agent TARS: General-purpose multimodal agent\n\n\nNext Steps#\n\n * Quick Start - Get started with your first Tarko agent\n * Architecture - Understand Tarko's design principles\n * Examples - Explore practical examples","routePath":"/guide/introduction","lang":"en","toc":[{"text":"What is Tarko?","id":"what-is-tarko","depth":2,"charIndex":196},{"text":"Key Features","id":"key-features","depth":2,"charIndex":567},{"text":"ðŸ”§ Tool Call Engine","id":"-tool-call-engine","depth":3,"charIndex":583},{"text":"ðŸŒŠ Event Stream","id":"-event-stream","depth":3,"charIndex":746},{"text":"ðŸ§  Context Engineering","id":"-context-engineering","depth":3,"charIndex":862},{"text":"ðŸ”Œ Agent Hooks","id":"-agent-hooks","depth":3,"charIndex":988},{"text":"Architecture Overview","id":"architecture-overview","depth":2,"charIndex":1090},{"text":"Who Uses Tarko?","id":"who-uses-tarko","depth":2,"charIndex":1351},{"text":"Next Steps","id":"next-steps","depth":2,"charIndex":1537}],"frontmatter":{"title":"Introduction","description":"Learn about Tarko, a tool-augmented agent runtime kernel"},"version":""},{"title":"Quick Start","content":"#\n\nGet up and running with Tarko in just a few minutes.\n\n\nPrerequisites#\n\n * Node.js 18+\n * npm or pnpm\n\n\nInstallation#\n\n\nCreate a New Agent#\n\nThe fastest way to get started is using the Tarko CLI:\n\nnpm create tarko\n\n\nOr use the agent starter template:\n\ngit clone https://github.com/agent-infra/agent-starter\ncd agent-starter\nnpm install\n\n\n\nInstall Tarko Packages#\n\nFor manual setup, install the core packages:\n\nnpm install @tarko/agent @tarko/agent-cli\n\n\n\nBasic Usage#\n\n\n1. Define Your Agent#\n\nCreate an agent.ts file:\n\n\n\nconst agent = new Agent({\n  name: 'MyAgent',\n  description: 'A helpful assistant agent',\n  systemPrompt: 'You are a helpful assistant.',\n  tools: [\n    // Add your tools here\n  ],\n  modelProvider: {\n    apiKey: process.env.OPENAI_API_KEY,\n    baseURL: 'https://api.openai.com/v1',\n    model: 'gpt-4'\n  }\n});\n\nexport default agent;\n\n\n\n2. Run Your Agent#\n\nStart your agent with the CLI:\n\nnpx tarko run agent.ts\n\n\nThis will start a local server with web UI at http://localhost:3000.\n\n\n3. Add Tools#\n\nExtend your agent with tools:\n\n\n\nconst weatherTool = createTool({\n  name: 'get_weather',\n  description: 'Get current weather for a location',\n  parameters: {\n    type: 'object',\n    properties: {\n      location: {\n        type: 'string',\n        description: 'The city and state, e.g. San Francisco, CA'\n      }\n    },\n    required: ['location']\n  },\n  handler: async ({ location }) => {\n    // Implement weather API call\n    return `Weather in ${location}: Sunny, 72Â°F`;\n  }\n});\n\nconst agent = new Agent({\n  // ... other config\n  tools: [weatherTool]\n});\n\n\n\nDevelopment Mode#\n\nFor development with hot reload:\n\nnpx tarko dev agent.ts\n\n\n\nEnvironment Variables#\n\nCreate a .env file:\n\n# .env file\nOPENAI_API_KEY=your-api-key\nMODEL_PROVIDER=openai\nMODEL_NAME=gpt-4\n\n\n\nNext Steps#\n\n * Architecture - Learn about Tarko's design\n * Context Engineering - Master long-running agents\n * Tool Call Engine - Build custom tools\n * Examples - Explore real-world examples\n\n\nCommon Issues#\n\n\nPort Already in Use#\n\nSpecify a different port:\n\nnpx tarko run agent.ts --port 3001\n\n\n\nMissing API Keys#\n\nEnsure your .env file contains the required API keys for your model provider.","routePath":"/guide/quick-start","lang":"en","toc":[{"text":"Prerequisites","id":"prerequisites","depth":2,"charIndex":57},{"text":"Installation","id":"installation","depth":2,"charIndex":105},{"text":"Create a New Agent","id":"create-a-new-agent","depth":3,"charIndex":121},{"text":"Install Tarko Packages","id":"install-tarko-packages","depth":3,"charIndex":340},{"text":"Basic Usage","id":"basic-usage","depth":2,"charIndex":456},{"text":"1. Define Your Agent","id":"1-define-your-agent","depth":3,"charIndex":471},{"text":"2. Run Your Agent","id":"2-run-your-agent","depth":3,"charIndex":856},{"text":"3. Add Tools","id":"3-add-tools","depth":3,"charIndex":1004},{"text":"Development Mode","id":"development-mode","depth":2,"charIndex":1578},{"text":"Environment Variables","id":"environment-variables","depth":2,"charIndex":1657},{"text":"Next Steps","id":"next-steps","depth":2,"charIndex":1784},{"text":"Common Issues","id":"common-issues","depth":2,"charIndex":1979},{"text":"Port Already in Use","id":"port-already-in-use","depth":3,"charIndex":1996},{"text":"Missing API Keys","id":"missing-api-keys","depth":3,"charIndex":2083}],"frontmatter":{"title":"Quick Start","description":"Get started with Tarko in minutes"},"version":""},{"title":"Server","content":"#\n\nTarko Agent Server is a production-ready server component built on top of Tarko\nAgent Core. It provides session management, storage capabilities, and a\nstandardized HTTP/WebSocket API for agent interactions.\n\n\nInstallation#\n\nnpm install @tarko/agent-server\n\n\n\nQuick Start#\n\n\nUsing CLI#\n\nThe easiest way to start a server:\n\nnpx tarko serve my-agent.ts\n\n\n\nProgrammatic Usage#\n\n\n\n\nconst server = new AgentServer({\n  agent: myAgent,\n  port: 8888,\n  storage: {\n    type: 'sqlite',\n    path: '~/.tarko'\n  }\n});\n\nawait server.start();\nconsole.log('Server running on http://localhost:8888');\n\n\n\nCore Concepts#\n\n\nSession#\n\nRepresents a complete agent interaction context, containing:\n\n * Message history\n * Tool calls and results\n * Agent state information\n * Metadata (name, tags, timestamps)\n\n\nQuery#\n\nA single request executed within a session:\n\n * Text input\n * Multimodal content (text + images)\n * Streaming or non-streaming execution\n\n\nConfiguration#\n\n\nServer Options#\n\ninterface ServerConfig {\n  agent: Agent;\n  port?: number;\n  host?: string;\n  basePath?: string; // Default: '/api/v1'\n  cors?: CorsOptions;\n  storage?: StorageConfig;\n  auth?: AuthConfig;\n  sharing?: SharingConfig;\n}\n\n\n\nStorage Configuration#\n\ninterface StorageConfig {\n  type: 'memory' | 'file' | 'sqlite' | 'redis';\n  path?: string; // For file/sqlite storage\n  connectionString?: string; // For redis storage\n  options?: Record<string, any>;\n}\n\n\n\nExample Configuration#\n\nconst server = new AgentServer({\n  agent: myAgent,\n  port: 8888,\n  storage: {\n    type: 'sqlite',\n    path: '~/.tarko/sessions.db'\n  },\n  cors: {\n    origin: ['http://localhost:3000'],\n    credentials: true\n  },\n  auth: {\n    enabled: true,\n    provider: 'jwt',\n    secret: process.env.JWT_SECRET\n  }\n});\n\n\n\nSession Management API#\n\n\nCreate Session#\n\nPOST /api/v1/sessions/create\n\n\nResponse:\n\n{\n  \"sessionId\": \"unique-session-id\"\n}\n\n\n\nList Sessions#\n\nGET /api/v1/sessions\n\n\nResponse:\n\n{\n  \"sessions\": [\n    {\n      \"id\": \"session-id-1\",\n      \"createdAt\": 1622548800000,\n      \"updatedAt\": 1622548800000,\n      \"name\": \"Session Name\",\n      \"workspace\": \"/path/to/workspace\",\n      \"tags\": [\"tag1\", \"tag2\"]\n    }\n  ]\n}\n\n\n\nGet Session Details#\n\nGET /api/v1/sessions/details?sessionId=session-id\n\n\n\nUpdate Session#\n\nPOST /api/v1/sessions/update\n\n\nRequest:\n\n{\n  \"sessionId\": \"session-id\",\n  \"name\": \"New Session Name\",\n  \"tags\": [\"updated\", \"tags\"]\n}\n\n\n\nDelete Session#\n\nPOST /api/v1/sessions/delete\n\n\nRequest:\n\n{\n  \"sessionId\": \"session-id\"\n}\n\n\n\nQuery Execution API#\n\n\nStandard Query#\n\nPOST /api/v1/sessions/query\n\n\nText Query:\n\n{\n  \"sessionId\": \"session-id\",\n  \"query\": \"Hello, how can you help me?\"\n}\n\n\nMultimodal Query:\n\n{\n  \"sessionId\": \"session-id\",\n  \"query\": [\n    { \"type\": \"text\", \"text\": \"What's in this image?\" },\n    { \n      \"type\": \"image_url\", \n      \"image_url\": {\n        \"url\": \"data:image/jpeg;base64,...\"\n      }\n    }\n  ]\n}\n\n\n\nStreaming Query#\n\nPOST /api/v1/sessions/query/stream\n\n\nReturns Server-Sent Events (SSE) stream with real-time agent responses.\n\n\nAbort Query#\n\nPOST /api/v1/sessions/abort\n\n\nRequest:\n\n{\n  \"sessionId\": \"session-id\"\n}\n\n\n\nOne-shot API#\n\nFor simple use cases, execute queries without explicit session management:\n\n\nOne-shot Query#\n\nPOST /api/v1/oneshot/query\n\n\nRequest:\n\n{\n  \"query\": \"What's the weather like?\",\n  \"sessionName\": \"Weather Check\",\n  \"sessionTags\": [\"weather\", \"oneshot\"]\n}\n\n\n\nOne-shot Streaming#\n\nPOST /api/v1/oneshot/query/stream\n\n\n\nWebSocket API#\n\nFor real-time bidirectional communication:\n\n\n\nconst socket = io('http://localhost:8888');\n\n// Join a session\nsocket.emit('join-session', 'session-id');\n\n// Listen for agent events\nsocket.on('agent-event', (event) => {\n  console.log('Agent event:', event);\n});\n\n// Send a query\nsocket.emit('send-query', {\n  sessionId: 'session-id',\n  query: 'Hello!'\n});\n\n// Abort query\nsocket.emit('abort-query', { sessionId: 'session-id' });\n\n\n\nEvent Stream Format#\n\nTarko Server uses structured event streams following the Agent Protocol:\n\ninterface AgentEvent {\n  id: string;\n  type: string;\n  timestamp: number;\n  sessionId: string;\n  data: any;\n}\n\n\nExample Event Stream:\n\n[\n  {\n    \"id\": \"evt-1\",\n    \"type\": \"user_message\",\n    \"timestamp\": 1622548800000,\n    \"sessionId\": \"session-1\",\n    \"data\": { \"content\": \"Hello!\" }\n  },\n  {\n    \"id\": \"evt-2\",\n    \"type\": \"assistant_message_start\",\n    \"timestamp\": 1622548800100,\n    \"sessionId\": \"session-1\",\n    \"data\": {}\n  },\n  {\n    \"id\": \"evt-3\",\n    \"type\": \"assistant_message_delta\",\n    \"timestamp\": 1622548800150,\n    \"sessionId\": \"session-1\",\n    \"data\": { \"delta\": \"Hello! How\" }\n  },\n  {\n    \"id\": \"evt-4\",\n    \"type\": \"tool_call\",\n    \"timestamp\": 1622548800200,\n    \"sessionId\": \"session-1\",\n    \"data\": {\n      \"name\": \"get_weather\",\n      \"arguments\": { \"location\": \"San Francisco\" }\n    }\n  }\n]\n\n\n\nStorage Providers#\n\n\nMemory Storage (Default)#\n\nstorage: {\n  type: 'memory'\n  // Data lost on server restart\n}\n\n\n\nFile Storage#\n\nstorage: {\n  type: 'file',\n  path: '~/.tarko/sessions'\n}\n\n\n\nSQLite Storage#\n\nstorage: {\n  type: 'sqlite',\n  path: '~/.tarko/sessions.db'\n}\n\n\n\nRedis Storage#\n\nstorage: {\n  type: 'redis',\n  connectionString: 'redis://localhost:6379',\n  options: {\n    keyPrefix: 'tarko:',\n    db: 0\n  }\n}\n\n\n\nAuthentication#\n\n\nJWT Authentication#\n\nconst server = new AgentServer({\n  auth: {\n    enabled: true,\n    provider: 'jwt',\n    secret: process.env.JWT_SECRET,\n    expiresIn: '24h'\n  }\n});\n\n\n\nCustom Authentication#\n\nconst server = new AgentServer({\n  auth: {\n    enabled: true,\n    provider: 'custom',\n    authenticate: async (req) => {\n      const token = req.headers.authorization;\n      // Custom authentication logic\n      return { userId: 'user-123', permissions: ['read', 'write'] };\n    }\n  }\n});\n\n\n\nMiddleware Extensions#\n\nExtend server functionality with custom middleware:\n\n\n\nconst server = new AgentServer(config);\nconst app = server.getApp();\n\n// Add custom routes\napp.get('/custom/health', (req, res) => {\n  res.json({ status: 'custom-ok', timestamp: Date.now() });\n});\n\n// Add middleware\napp.use('/api/v1', express.json({ limit: '50mb' }));\n\n// Custom error handling\napp.use((error, req, res, next) => {\n  console.error('Server error:', error);\n  res.status(500).json({ error: 'Internal server error' });\n});\n\nawait server.start();\n\n\n\nDeployment#\n\n\nDocker Deployment#\n\nFROM node:18-alpine\n\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --production\n\nCOPY . .\nEXPOSE 8888\n\nCMD [\"npx\", \"tarko\", \"serve\", \"agent.ts\", \"--port\", \"8888\"]\n\n\n\nEnvironment Variables#\n\n# .env\nPORT=8888\nNODE_ENV=production\nJWT_SECRET=your-secret-key\nSTORAGE_TYPE=sqlite\nSTORAGE_PATH=/data/sessions.db\nOPENAI_API_KEY=your-api-key\n\n\n\nProduction Configuration#\n\n// production.config.ts\nexport default {\n  server: {\n    port: process.env.PORT || 8888,\n    storage: {\n      type: 'sqlite',\n      path: process.env.STORAGE_PATH || '/data/sessions.db'\n    },\n    auth: {\n      enabled: true,\n      provider: 'jwt',\n      secret: process.env.JWT_SECRET\n    },\n    cors: {\n      origin: process.env.ALLOWED_ORIGINS?.split(',') || ['https://your-domain.com'],\n      credentials: true\n    }\n  }\n};\n\n\n\nMonitoring and Logging#\n\n\nHealth Check#\n\nGET /api/v1/health\n\n\nResponse:\n\n{\n  \"status\": \"ok\",\n  \"timestamp\": 1622548800000,\n  \"uptime\": 3600,\n  \"memory\": {\n    \"used\": 123456789,\n    \"total\": 1073741824\n  }\n}\n\n\n\nCustom Logging#\n\nconst server = new AgentServer({\n  logging: {\n    level: 'info',\n    format: 'json',\n    transports: [\n      { type: 'console' },\n      { type: 'file', filename: 'tarko-server.log' }\n    ]\n  }\n});\n\n\n\nBest Practices#\n\n\n1. Session Management#\n\n * Implement session cleanup for old/inactive sessions\n * Use appropriate storage based on scale requirements\n * Consider session sharing and collaboration features\n\n\n2. Security#\n\n * Always enable authentication in production\n * Use HTTPS in production environments\n * Implement rate limiting for public APIs\n * Validate and sanitize all inputs\n\n\n3. Performance#\n\n * Use Redis for high-concurrency scenarios\n * Implement connection pooling for database storage\n * Monitor memory usage and implement cleanup\n * Use streaming for long-running queries\n\n\n4. Error Handling#\n\n * Implement comprehensive error logging\n * Provide meaningful error messages to clients\n * Handle agent timeouts gracefully\n * Implement circuit breakers for external dependencies\n\n\nNext Steps#\n\n * Agent Protocol - Understand the communication standards\n * Agent Hooks - Extend server behavior\n * Examples - See server integration examples","routePath":"/guide/server","lang":"en","toc":[{"text":"Installation","id":"installation","depth":2,"charIndex":212},{"text":"Quick Start","id":"quick-start","depth":2,"charIndex":262},{"text":"Using CLI","id":"using-cli","depth":3,"charIndex":277},{"text":"Programmatic Usage","id":"programmatic-usage","depth":3,"charIndex":356},{"text":"Core Concepts","id":"core-concepts","depth":2,"charIndex":589},{"text":"Session","id":"session","depth":3,"charIndex":606},{"text":"Query","id":"query","depth":3,"charIndex":789},{"text":"Configuration","id":"configuration","depth":2,"charIndex":936},{"text":"Server Options","id":"server-options","depth":3,"charIndex":953},{"text":"Storage Configuration","id":"storage-configuration","depth":3,"charIndex":1190},{"text":"Example Configuration","id":"example-configuration","depth":3,"charIndex":1420},{"text":"Session Management API","id":"session-management-api","depth":2,"charIndex":1752},{"text":"Create Session","id":"create-session","depth":3,"charIndex":1778},{"text":"List Sessions","id":"list-sessions","depth":3,"charIndex":1879},{"text":"Get Session Details","id":"get-session-details","depth":3,"charIndex":2166},{"text":"Update Session","id":"update-session","depth":3,"charIndex":2241},{"text":"Delete Session","id":"delete-session","depth":3,"charIndex":2395},{"text":"Query Execution API","id":"query-execution-api","depth":2,"charIndex":2488},{"text":"Standard Query","id":"standard-query","depth":3,"charIndex":2511},{"text":"Streaming Query","id":"streaming-query","depth":3,"charIndex":2890},{"text":"Abort Query","id":"abort-query","depth":3,"charIndex":3019},{"text":"One-shot API","id":"one-shot-api","depth":2,"charIndex":3108},{"text":"One-shot Query","id":"one-shot-query","depth":3,"charIndex":3200},{"text":"One-shot Streaming","id":"one-shot-streaming","depth":3,"charIndex":3376},{"text":"WebSocket API","id":"websocket-api","depth":2,"charIndex":3434},{"text":"Event Stream Format","id":"event-stream-format","depth":2,"charIndex":3880},{"text":"Storage Providers","id":"storage-providers","depth":2,"charIndex":4797},{"text":"Memory Storage (Default)","id":"memory-storage-default","depth":3,"charIndex":4818},{"text":"File Storage","id":"file-storage","depth":3,"charIndex":4911},{"text":"SQLite Storage","id":"sqlite-storage","depth":3,"charIndex":4986},{"text":"Redis Storage","id":"redis-storage","depth":3,"charIndex":5068},{"text":"Authentication","id":"authentication","depth":2,"charIndex":5215},{"text":"JWT Authentication","id":"jwt-authentication","depth":3,"charIndex":5233},{"text":"Custom Authentication","id":"custom-authentication","depth":3,"charIndex":5405},{"text":"Middleware Extensions","id":"middleware-extensions","depth":2,"charIndex":5720},{"text":"Deployment","id":"deployment","depth":2,"charIndex":6262},{"text":"Docker Deployment","id":"docker-deployment","depth":3,"charIndex":6276},{"text":"Environment Variables","id":"environment-variables","depth":3,"charIndex":6462},{"text":"Production Configuration","id":"production-configuration","depth":3,"charIndex":6632},{"text":"Monitoring and Logging","id":"monitoring-and-logging","depth":2,"charIndex":7090},{"text":"Health Check","id":"health-check","depth":3,"charIndex":7116},{"text":"Custom Logging","id":"custom-logging","depth":3,"charIndex":7301},{"text":"Best Practices","id":"best-practices","depth":2,"charIndex":7518},{"text":"1. Session Management","id":"1-session-management","depth":3,"charIndex":7536},{"text":"2. Security","id":"2-security","depth":3,"charIndex":7727},{"text":"3. Performance","id":"3-performance","depth":3,"charIndex":7908},{"text":"4. Error Handling","id":"4-error-handling","depth":3,"charIndex":8112},{"text":"Next Steps","id":"next-steps","depth":2,"charIndex":8315}],"frontmatter":{"title":"Server","description":"Build production-ready agent servers with Tarko Agent Server"},"version":""},{"title":"Tool Call Engine","content":"#\n\nTarko's Tool Call Engine provides a unified interface for tool integration that\nworks across different LLM providers, regardless of their native tool support\ncapabilities.\n\n\nOverview#\n\nThe Tool Call Engine solves several key challenges:\n\n * Provider Compatibility: Works with models that don't support native Function\n   Calling\n * Custom Parsers: Implement custom parsing logic for specialized use cases\n * Unified Interface: Consistent tool interface following OpenAI Function Call\n   protocol\n * Flexible Execution: Support for sync/async tools, streaming, and error\n   handling\n\n\nBasic Tool Creation#\n\n\nSimple Tool#\n\n\n\nconst weatherTool = createTool({\n  name: 'get_weather',\n  description: 'Get current weather for a location',\n  parameters: {\n    type: 'object',\n    properties: {\n      location: {\n        type: 'string',\n        description: 'The city and state, e.g. San Francisco, CA'\n      },\n      unit: {\n        type: 'string',\n        enum: ['celsius', 'fahrenheit'],\n        default: 'fahrenheit'\n      }\n    },\n    required: ['location']\n  },\n  handler: async ({ location, unit = 'fahrenheit' }) => {\n    // Implement weather API call\n    const response = await fetch(`https://api.weather.com/v1/current?location=${location}&unit=${unit}`);\n    const data = await response.json();\n    return `Weather in ${location}: ${data.condition}, ${data.temperature}Â°${unit.charAt(0).toUpperCase()}`;\n  }\n});\n\n\n\nTool with Validation#\n\nconst calculatorTool = createTool({\n  name: 'calculate',\n  description: 'Perform mathematical calculations',\n  parameters: {\n    type: 'object',\n    properties: {\n      expression: {\n        type: 'string',\n        description: 'Mathematical expression to evaluate'\n      }\n    },\n    required: ['expression']\n  },\n  validate: ({ expression }) => {\n    // Validate expression safety\n    if (/[^0-9+\\-*/().\\s]/.test(expression)) {\n      throw new Error('Invalid characters in expression');\n    }\n    return true;\n  },\n  handler: async ({ expression }) => {\n    try {\n      const result = eval(expression); // In production, use a safe math evaluator\n      return `${expression} = ${result}`;\n    } catch (error) {\n      return `Error calculating ${expression}: ${error.message}`;\n    }\n  }\n});\n\n\n\nTool Call Engines#\n\nTarko supports multiple Tool Call Engine implementations:\n\n\n1. Native Function Call Engine#\n\nFor models that support OpenAI-compatible function calling:\n\n\n\nconst agent = new Agent({\n  toolCallEngine: new NativeFunctionCallEngine({\n    parallel: true, // Enable parallel tool calls\n    maxCalls: 5,    // Maximum calls per turn\n    timeout: 30000  // 30 second timeout\n  }),\n  tools: [weatherTool, calculatorTool]\n});\n\n\n\n2. Prompt Engineering Engine#\n\nFor models without native function call support:\n\n\n\nconst agent = new Agent({\n  toolCallEngine: new PromptEngineeringToolCallEngine({\n    parser: 'json',     // 'json' | 'xml' | 'yaml' | 'custom'\n    format: 'openai',   // Output format\n    retries: 3,         // Parse retry attempts\n    fallback: 'text'    // Fallback when parsing fails\n  }),\n  tools: [weatherTool]\n});\n\n\n\n3. Custom Tool Call Engine#\n\nImplement your own parsing logic:\n\n\n\nclass CustomToolCallEngine extends BaseToolCallEngine {\n  async parseToolCalls(response: string): Promise<ToolCall[]> {\n    // Custom parsing logic\n    const matches = response.match(/\\[TOOL:(\\w+)\\]\\[ARGS:(.+?)\\]/g);\n    \n    return matches?.map(match => {\n      const [, name, argsStr] = match.match(/\\[TOOL:(\\w+)\\]\\[ARGS:(.+?)\\]/)!;\n      return {\n        id: generateId(),\n        type: 'function',\n        function: {\n          name,\n          arguments: argsStr\n        }\n      };\n    }) || [];\n  }\n  \n  formatToolsForPrompt(tools: Tool[]): string {\n    // Custom tool formatting for prompt\n    return tools.map(tool => \n      `[TOOL:${tool.name}] ${tool.description}\\nParameters: ${JSON.stringify(tool.parameters)}`\n    ).join('\\n\\n');\n  }\n}\n\nconst agent = new Agent({\n  toolCallEngine: new CustomToolCallEngine(),\n  tools: [weatherTool]\n});\n\n\n\nAdvanced Tool Features#\n\n\nStreaming Tools#\n\nFor tools that return large amounts of data:\n\nconst searchTool = createTool({\n  name: 'web_search',\n  description: 'Search the web for information',\n  parameters: {\n    type: 'object',\n    properties: {\n      query: { type: 'string' },\n      limit: { type: 'number', default: 5 }\n    },\n    required: ['query']\n  },\n  streaming: true,\n  handler: async function* ({ query, limit = 5 }) {\n    yield `Searching for: ${query}...`;\n    \n    const results = await searchAPI(query, limit);\n    \n    for (const result of results) {\n      yield `Found: ${result.title} - ${result.url}`;\n      await new Promise(resolve => setTimeout(resolve, 100)); // Simulate processing\n    }\n    \n    return `Search completed. Found ${results.length} results.`;\n  }\n});\n\n\n\nTool with Context Access#\n\nAccess agent context and session data:\n\nconst contextTool = createTool({\n  name: 'analyze_conversation',\n  description: 'Analyze the current conversation',\n  parameters: {\n    type: 'object',\n    properties: {\n      aspect: {\n        type: 'string',\n        enum: ['sentiment', 'topics', 'summary']\n      }\n    },\n    required: ['aspect']\n  },\n  handler: async ({ aspect }, context) => {\n    const { messages, sessionId, agentState } = context;\n    \n    switch (aspect) {\n      case 'sentiment':\n        const userMessages = messages.filter(m => m.role === 'user');\n        return `Analyzed ${userMessages.length} user messages. Overall sentiment: positive`;\n      \n      case 'topics':\n        const topics = extractTopics(messages);\n        return `Main topics discussed: ${topics.join(', ')}`;\n      \n      case 'summary':\n        return `Session ${sessionId}: ${messages.length} messages exchanged`;\n    }\n  }\n});\n\n\n\nTool Dependencies#\n\nDefine tools that depend on other tools:\n\nconst fileReadTool = createTool({\n  name: 'read_file',\n  description: 'Read contents of a file',\n  parameters: {\n    type: 'object',\n    properties: {\n      path: { type: 'string' }\n    },\n    required: ['path']\n  },\n  handler: async ({ path }) => {\n    const fs = await import('fs/promises');\n    return await fs.readFile(path, 'utf-8');\n  }\n});\n\nconst analyzeCodeTool = createTool({\n  name: 'analyze_code',\n  description: 'Analyze code from a file',\n  parameters: {\n    type: 'object',\n    properties: {\n      filePath: { type: 'string' },\n      analysisType: { \n        type: 'string',\n        enum: ['complexity', 'security', 'performance']\n      }\n    },\n    required: ['filePath', 'analysisType']\n  },\n  dependencies: [fileReadTool],\n  handler: async ({ filePath, analysisType }, context) => {\n    // Use the file read tool\n    const fileContent = await context.callTool('read_file', { path: filePath });\n    \n    // Analyze the code\n    switch (analysisType) {\n      case 'complexity':\n        return analyzeComplexity(fileContent);\n      case 'security':\n        return analyzeSecurity(fileContent);\n      case 'performance':\n        return analyzePerformance(fileContent);\n    }\n  }\n});\n\n\n\nTool Configuration#\n\n\nTool Groups#\n\nOrganize tools into logical groups:\n\n\n\nconst fileSystemTools = createToolGroup({\n  name: 'filesystem',\n  description: 'File system operations',\n  tools: [\n    createTool({ name: 'read_file', /* ... */ }),\n    createTool({ name: 'write_file', /* ... */ }),\n    createTool({ name: 'list_directory', /* ... */ })\n  ],\n  permissions: ['read', 'write'],\n  rateLimit: {\n    maxCalls: 10,\n    window: 60000 // 1 minute\n  }\n});\n\nconst agent = new Agent({\n  toolGroups: [fileSystemTools]\n});\n\n\n\nConditional Tools#\n\nEnable tools based on conditions:\n\nconst conditionalTool = createTool({\n  name: 'admin_action',\n  description: 'Perform administrative action',\n  parameters: { /* ... */ },\n  condition: (context) => {\n    return context.user?.role === 'admin';\n  },\n  handler: async (params, context) => {\n    // Admin-only functionality\n  }\n});\n\n\n\nError Handling#\n\n\nTool Error Handling#\n\nconst robustTool = createTool({\n  name: 'api_call',\n  description: 'Make an API call with retry logic',\n  parameters: {\n    type: 'object',\n    properties: {\n      url: { type: 'string' },\n      method: { type: 'string', default: 'GET' }\n    },\n    required: ['url']\n  },\n  retries: 3,\n  timeout: 10000,\n  errorHandler: (error, attempt, maxAttempts) => {\n    console.log(`Tool call failed (attempt ${attempt}/${maxAttempts}):`, error.message);\n    \n    if (attempt < maxAttempts) {\n      return { retry: true, delay: 1000 * attempt }; // Exponential backoff\n    }\n    \n    return { \n      retry: false, \n      fallbackResult: `API call failed after ${maxAttempts} attempts: ${error.message}`\n    };\n  },\n  handler: async ({ url, method }) => {\n    const response = await fetch(url, { method });\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n    return await response.text();\n  }\n});\n\n\n\nGlobal Error Handling#\n\nconst agent = new Agent({\n  toolCallEngine: new NativeFunctionCallEngine({\n    errorHandler: (error, toolCall, context) => {\n      // Log error\n      console.error(`Tool ${toolCall.function.name} failed:`, error);\n      \n      // Return user-friendly error message\n      return `I encountered an error while using the ${toolCall.function.name} tool. Please try again or rephrase your request.`;\n    }\n  })\n});\n\n\n\nTesting Tools#\n\n\nUnit Testing#\n\n\n\ndescribe('Weather Tool', () => {\n  const weatherTool = createTool({\n    name: 'get_weather',\n    // ... tool definition\n  });\n  \n  it('should return weather information', async () => {\n    const result = await testTool(weatherTool, {\n      location: 'San Francisco, CA'\n    });\n    \n    expect(result).toContain('San Francisco');\n    expect(result).toMatch(/\\d+Â°[CF]/);\n  });\n  \n  it('should handle invalid locations', async () => {\n    await expect(testTool(weatherTool, {\n      location: 'Invalid Location'\n    })).rejects.toThrow('Location not found');\n  });\n});\n\n\n\nIntegration Testing#\n\n\n\ndescribe('Agent with Tools', () => {\n  let agent: Agent;\n  \n  beforeEach(() => {\n    agent = createMockAgent({\n      tools: [weatherTool, calculatorTool]\n    });\n  });\n  \n  it('should use tools correctly', async () => {\n    const response = await agent.query('What\\'s the weather in NYC and what\\'s 2+2?');\n    \n    expect(response.toolCalls).toHaveLength(2);\n    expect(response.toolCalls[0].function.name).toBe('get_weather');\n    expect(response.toolCalls[1].function.name).toBe('calculate');\n  });\n});\n\n\n\nBest Practices#\n\n\n1. Tool Design#\n\n * Keep tools focused on single responsibilities\n * Use descriptive names and clear descriptions\n * Validate inputs thoroughly\n * Handle errors gracefully\n * Provide meaningful error messages\n\n\n2. Performance#\n\n * Implement timeouts for external API calls\n * Use caching for expensive operations\n * Consider streaming for large responses\n * Implement rate limiting for external services\n\n\n3. Security#\n\n * Validate and sanitize all inputs\n * Implement proper authentication for sensitive tools\n * Use least privilege principle\n * Audit tool usage and access patterns\n\n\n4. Debugging#\n\n * Add comprehensive logging\n * Use structured error messages\n * Implement tool call tracing\n * Test tools in isolation\n\n\nNext Steps#\n\n * Agent Protocol - Understand tool call events\n * Agent Hooks - Extend tool behavior\n * Examples - See real-world tool implementations","routePath":"/guide/tool-call-engine","lang":"en","toc":[{"text":"Overview","id":"overview","depth":2,"charIndex":176},{"text":"Basic Tool Creation","id":"basic-tool-creation","depth":2,"charIndex":586},{"text":"Simple Tool","id":"simple-tool","depth":3,"charIndex":609},{"text":"Tool with Validation","id":"tool-with-validation","depth":3,"charIndex":1419},{"text":"Tool Call Engines","id":"tool-call-engines","depth":2,"charIndex":2238},{"text":"1. Native Function Call Engine","id":"1-native-function-call-engine","depth":3,"charIndex":2318},{"text":"2. Prompt Engineering Engine","id":"2-prompt-engineering-engine","depth":3,"charIndex":2678},{"text":"3. Custom Tool Call Engine","id":"3-custom-tool-call-engine","depth":3,"charIndex":3085},{"text":"Advanced Tool Features","id":"advanced-tool-features","depth":2,"charIndex":4002},{"text":"Streaming Tools","id":"streaming-tools","depth":3,"charIndex":4028},{"text":"Tool with Context Access","id":"tool-with-context-access","depth":3,"charIndex":4796},{"text":"Tool Dependencies","id":"tool-dependencies","depth":3,"charIndex":5744},{"text":"Tool Configuration","id":"tool-configuration","depth":2,"charIndex":7005},{"text":"Tool Groups","id":"tool-groups","depth":3,"charIndex":7027},{"text":"Conditional Tools","id":"conditional-tools","depth":3,"charIndex":7527},{"text":"Error Handling","id":"error-handling","depth":2,"charIndex":7879},{"text":"Tool Error Handling","id":"tool-error-handling","depth":3,"charIndex":7897},{"text":"Global Error Handling","id":"global-error-handling","depth":3,"charIndex":8863},{"text":"Testing Tools","id":"testing-tools","depth":2,"charIndex":9300},{"text":"Unit Testing","id":"unit-testing","depth":3,"charIndex":9317},{"text":"Integration Testing","id":"integration-testing","depth":3,"charIndex":9903},{"text":"Best Practices","id":"best-practices","depth":2,"charIndex":10436},{"text":"1. Tool Design","id":"1-tool-design","depth":3,"charIndex":10454},{"text":"2. Performance","id":"2-performance","depth":3,"charIndex":10665},{"text":"3. Security","id":"3-security","depth":3,"charIndex":10860},{"text":"4. Debugging","id":"4-debugging","depth":3,"charIndex":11040},{"text":"Next Steps","id":"next-steps","depth":2,"charIndex":11177}],"frontmatter":{"title":"Tool Call Engine","description":"Build custom tools and parsers with Tarko's unified Tool Call Engine"},"version":""}]